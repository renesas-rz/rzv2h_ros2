diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..337b033
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+#
+
+# darknet_drp_msgs is built by a recipe named darknet-ros-msgs
+# we use darknet_drp_ros only at this recipe.
+add_subdirectory(darknet_drp_ros)
diff --git a/darknet_ros/CHANGELOG.rst b/darknet_drp_ros/CHANGELOG.rst
similarity index 100%
rename from darknet_ros/CHANGELOG.rst
rename to darknet_drp_ros/CHANGELOG.rst
diff --git a/darknet_drp_ros/CMakeLists.txt b/darknet_drp_ros/CMakeLists.txt
new file mode 100644
index 0000000..5ec5bc9
--- /dev/null
+++ b/darknet_drp_ros/CMakeLists.txt
@@ -0,0 +1,105 @@
+cmake_minimum_required(VERSION 3.5)
+project(darknet_drp_ros)
+
+set(CMAKE_CXX_STANDARD 17)
+
+# Define path of darknet folder here.
+set(DARKNET_PATH ../darknet)
+#find_path(DARKNET_PATH
+#  NAMES "README.md"
+#  HINTS "${CMAKE_CURRENT_SOURCE_DIR}/../darknet/")
+#message(STATUS "Darknet path dir = ${DARKNET_PATH}")
+add_definitions(-DDARKNET_FILE_PATH="${DARKNET_PATH}")
+
+list(APPEND LIBRARIES "m")
+
+# Find rquired packeges
+find_package(OpenCV REQUIRED)
+include_directories(${OpenCV_INCLUDE_DIRS})
+
+find_package(ament_cmake REQUIRED)
+find_package(rclcpp REQUIRED)
+find_package(rclpy REQUIRED)
+find_package(rclcpp_action REQUIRED)
+find_package(std_msgs REQUIRED)
+find_package(image_transport REQUIRED)
+find_package(cv_bridge REQUIRED)
+find_package(sensor_msgs REQUIRED)
+find_package(darknet_ros_msgs REQUIRED)
+find_package(ament_index_cpp REQUIRED)
+
+set(dependencies
+    rclcpp
+    rclpy
+    rclcpp_action
+    std_msgs
+    image_transport
+    cv_bridge
+    sensor_msgs
+    darknet_ros_msgs
+    ament_index_cpp
+)
+
+# Enable OPENCV in darknet
+# add_definitions(-DOPENCV)
+add_definitions(-O4 -g)
+
+set(TVM_ROOT $ENV{TVM_HOME})
+include_directories(
+${TVM_ROOT}/include
+${TVM_ROOT}/3rdparty/dlpack/include
+${TVM_ROOT}/3rdparty/dmlc-core/include
+${TVM_ROOT}/3rdparty/compiler-rt
+)
+
+include_directories(
+  ${DARKNET_PATH}/src
+  ${DARKNET_PATH}/include
+  include
+  include/darknet_drp_ros
+  ${catkin_INCLUDE_DIRS}
+)
+
+add_executable(${PROJECT_NAME}
+    src/main.cpp
+    src/box.cpp
+    src/image_yolox.cpp
+    src/ascii.cpp
+    src/PreRuntimeV2H.cpp
+    src/MeraDrpRuntimeWrapper.cpp
+)
+ament_target_dependencies(${PROJECT_NAME} ${dependencies})
+
+target_link_libraries(${PROJECT_NAME} 
+  m
+  pthread
+  stdc++
+  ${OpenCV_LIBRARIES}
+  ${catkin_LIBRARIES}
+  ${OpenCV_LIBS}
+  mmngr
+  mmngrbuf
+  tvm_runtime
+)
+
+target_compile_definitions(${PROJECT_NAME} PRIVATE -DOPENCV)
+
+install(TARGETS ${PROJECT_NAME}
+  ARCHIVE DESTINATION lib
+  LIBRARY DESTINATION lib
+  RUNTIME DESTINATION lib/${PROJECT_NAME}
+)
+
+
+install(
+  DIRECTORY include/
+  DESTINATION include/
+  FILES_MATCHING PATTERN "*.h"
+)
+
+install(DIRECTORY launch config DESTINATION share/${PROJECT_NAME}/)
+
+ament_export_include_directories(include)
+ament_export_dependencies(${dependencies})
+
+ament_package()
diff --git a/darknet_ros/config/ros.yaml b/darknet_drp_ros/config/ros.yaml
similarity index 100%
rename from darknet_ros/config/ros.yaml
rename to darknet_drp_ros/config/ros.yaml
diff --git a/darknet_ros/config/yolov2-tiny-voc.yaml b/darknet_drp_ros/config/yolov2-tiny-voc.yaml
similarity index 100%
rename from darknet_ros/config/yolov2-tiny-voc.yaml
rename to darknet_drp_ros/config/yolov2-tiny-voc.yaml
diff --git a/darknet_ros/config/yolov2-tiny.yaml b/darknet_drp_ros/config/yolov2-tiny.yaml
similarity index 100%
rename from darknet_ros/config/yolov2-tiny.yaml
rename to darknet_drp_ros/config/yolov2-tiny.yaml
diff --git a/darknet_ros/config/yolov2-voc.yaml b/darknet_drp_ros/config/yolov2-voc.yaml
similarity index 100%
rename from darknet_ros/config/yolov2-voc.yaml
rename to darknet_drp_ros/config/yolov2-voc.yaml
diff --git a/darknet_ros/config/yolov2.yaml b/darknet_drp_ros/config/yolov2.yaml
similarity index 100%
rename from darknet_ros/config/yolov2.yaml
rename to darknet_drp_ros/config/yolov2.yaml
diff --git a/darknet_ros/config/yolov3-voc.yaml b/darknet_drp_ros/config/yolov3-voc.yaml
similarity index 100%
rename from darknet_ros/config/yolov3-voc.yaml
rename to darknet_drp_ros/config/yolov3-voc.yaml
diff --git a/darknet_ros/config/yolov3.yaml b/darknet_drp_ros/config/yolov3.yaml
similarity index 100%
rename from darknet_ros/config/yolov3.yaml
rename to darknet_drp_ros/config/yolov3.yaml
diff --git a/darknet_ros/doc/quadruped_anymal_and_person.JPG b/darknet_drp_ros/doc/quadruped_anymal_and_person.JPG
similarity index 100%
rename from darknet_ros/doc/quadruped_anymal_and_person.JPG
rename to darknet_drp_ros/doc/quadruped_anymal_and_person.JPG
diff --git a/darknet_ros/doc/test_detection.png b/darknet_drp_ros/doc/test_detection.png
similarity index 100%
rename from darknet_ros/doc/test_detection.png
rename to darknet_drp_ros/doc/test_detection.png
diff --git a/darknet_ros/doc/test_detection_anymal.png b/darknet_drp_ros/doc/test_detection_anymal.png
similarity index 100%
rename from darknet_ros/doc/test_detection_anymal.png
rename to darknet_drp_ros/doc/test_detection_anymal.png
diff --git a/darknet_drp_ros/launch/darknet_drp_ros_launch.py b/darknet_drp_ros/launch/darknet_drp_ros_launch.py
new file mode 100644
index 0000000..0df24a6
--- /dev/null
+++ b/darknet_drp_ros/launch/darknet_drp_ros_launch.py
@@ -0,0 +1,29 @@
+#
+# Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+#
+
+# launch script for darknet_drp_ros package.
+
+import os
+
+from ament_index_python.packages import get_package_share_directory
+
+from launch import LaunchDescription
+from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, SetEnvironmentVariable
+from launch.launch_description_sources import PythonLaunchDescriptionSource
+from launch.substitutions import LaunchConfiguration
+from launch_ros.actions import Node
+
+def generate_launch_description():
+
+    drpai_cmd = Node(
+        package='darknet_drp_ros',
+        executable='darknet_drp_ros',
+        name='darknet_drp_ros',
+        output='screen')
+
+    ld = LaunchDescription()
+
+    ld.add_action(drpai_cmd)
+
+    return ld
diff --git a/darknet_ros/package.xml b/darknet_drp_ros/package.xml
similarity index 94%
rename from darknet_ros/package.xml
rename to darknet_drp_ros/package.xml
index 9df4490..fd6f58c 100644
--- a/darknet_ros/package.xml
+++ b/darknet_drp_ros/package.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
 <package format="3">
-  <name>darknet_ros</name>
+  <name>darknet_drp_ros</name>
   <version>1.1.4</version>
   <description>Darknet is an open source neural network framework that runs on CPU and GPU. You only look once (YOLO) is a state-of-the-art, real-time object detection system.</description>
   <maintainer email="marko.bjelonic@mavt.ethz.ch">Marko Bjelonic</maintainer>
@@ -18,7 +18,6 @@
   <depend>image_transport</depend>
   <depend>cv_bridge</depend>
   <depend>sensor_msgs</depend>
-  <depend>darknet_ros_msgs</depend>
   <depend>ament_index_cpp</depend>
 
   <test_depend>ament_lint_common</test_depend>
diff --git a/darknet_drp_ros/src/MeraDrpRuntimeWrapper.cpp b/darknet_drp_ros/src/MeraDrpRuntimeWrapper.cpp
new file mode 100644
index 0000000..a29e790
--- /dev/null
+++ b/darknet_drp_ros/src/MeraDrpRuntimeWrapper.cpp
@@ -0,0 +1,230 @@
+/*
+ * Original Code (C) Copyright Edgecortix, Inc. 2022
+ * Modified Code (C) Copyright Renesas Electronics Corporation 2024ã€€
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+#include <tvm/runtime/module.h>
+#include <tvm/runtime/packed_func.h>
+#include <tvm/runtime/registry.h>
+#include <tvm/runtime/profiling.h>
+
+#include <fstream>
+#include <regex>
+#include <dirent.h>
+#include "MeraDrpRuntimeWrapper.h"
+
+#include "rclcpp/rclcpp.hpp"
+
+template <typename T>
+static std::vector<T> LoadBinary(const std::string& bin_file) {
+  std::ifstream file(bin_file.c_str(), std::ios::in | std::ios::binary);
+  if (!file.is_open()) {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "unable to open file %s", bin_file.c_str());
+  }
+
+  file.seekg(0, file.end);
+  const uint32_t file_size = static_cast<uint32_t>(file.tellg());
+  file.seekg(0, file.beg);
+
+  const auto file_buffer = std::unique_ptr<char>(new char[file_size]);
+  file.read(file_buffer.get(), file_size);
+
+  if (file.bad() || file.fail()) {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "error occured while reading the file");
+  }
+
+  file.close();
+
+  auto ptr = reinterpret_cast<T*>(file_buffer.get());
+  const auto num_elements = file_size / sizeof(T);
+  return std::vector<T>(ptr, ptr + num_elements);
+}
+
+MeraDrpRuntimeWrapper::MeraDrpRuntimeWrapper() {
+  //device_type = kDLCPU;
+  device_type = kDLDrpAi;
+  device_id = 0;
+};
+
+MeraDrpRuntimeWrapper::~MeraDrpRuntimeWrapper() = default;
+
+bool MeraDrpRuntimeWrapper::LoadModel(const std::string& model_dir, uint32_t start_address){
+    device_type = kDLCPU;
+
+    return LoadModel(model_dir, (uint64_t)start_address);
+}
+
+bool MeraDrpRuntimeWrapper::LoadModel(const std::string& model_dir, uint64_t start_address = 0x00) {
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Loading json data...");
+    const std::string json_file(model_dir + "/deploy.json");
+    std::ifstream json_in(json_file.c_str(), std::ios::in);
+    std::string json_data((std::istreambuf_iterator<char>(json_in)), std::istreambuf_iterator<char>());
+    json_in.close();
+
+    #if 0
+    if(json_data.find("drp") == json_data.npos && device_type != kDLCPU){
+        LOG(INFO) <<"Break! this model is Not for DRP-AI retry as CPU Only";
+        return false;
+    }
+    #else
+    if(json_data.find("drp") == json_data.npos && device_type != kDLCPU){
+        LOG(INFO) <<"try as CPU Only";
+        device_type = kDLCPU;
+    }
+    #endif
+
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Loading runtime module...");
+    tvm::runtime::Module mod_syslib = tvm::runtime::Module::LoadFromFile(model_dir + "/deploy.so");
+    mod = (*tvm::runtime::Registry::Get("tvm.graph_executor_debug.create"))(
+      json_data, mod_syslib, device_type, device_id);
+
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Loading parameters...");
+    tvm::runtime::PackedFunc load_params = mod.GetFunction("load_params");
+    auto params_data = LoadBinary<char>(model_dir + "/deploy.params");
+    TVMByteArray params_arr;
+    params_arr.data = params_data.data();
+    params_arr.size = params_data.size();
+    load_params(params_arr);
+    tvm::runtime::PackedFunc set_start_address = mod.GetFunction("set_start_address");
+    if(set_start_address != nullptr){
+      set_start_address(start_address);
+    }
+    return true;
+}
+
+template <typename T>
+void MeraDrpRuntimeWrapper::SetInput(int input_index, const T* data_ptr) {
+    RCLCPP_DEBUG(rclcpp::get_logger("darknet_drp_ros"), "Loading input...");
+
+    tvm::runtime::PackedFunc get_input = mod.GetFunction("get_input");
+    tvm::runtime::NDArray xx = get_input(input_index);
+    auto in_shape = xx.Shape();
+    int64_t in_size = 1;
+    for (unsigned long i = 0; i < in_shape.size(); ++i) {
+      in_size *= in_shape[i];
+    }
+
+    DLDevice ctx;
+    ctx.device_id = device_id;
+    ctx.device_type = DLDeviceType(kDLCPU);
+
+    auto input_array = tvm::runtime::NDArray::Empty(in_shape, xx.DataType(), ctx);
+    auto input_data = (T*)(input_array->data);
+    std::memcpy(input_data, data_ptr, sizeof(T) * in_size);
+    tvm::runtime::PackedFunc set_input = mod.GetFunction("set_input");
+    set_input(input_index, input_array);
+}
+template void MeraDrpRuntimeWrapper::SetInput<float>(int input_index, const float*);
+template void MeraDrpRuntimeWrapper::SetInput<unsigned short>(int input_index, const unsigned short*);
+
+void MeraDrpRuntimeWrapper::Run() {
+    mod.GetFunction("run")();
+}
+
+void MeraDrpRuntimeWrapper::Run(int freq_index) {
+    mod.GetFunction("run")(freq_index);
+}
+
+void MeraDrpRuntimeWrapper::ProfileRun(const std::string& profile_table, const std::string& profile_csv) {
+    tvm::runtime::PackedFunc profile = mod.GetFunction("profile");
+    tvm::runtime::Array<tvm::runtime::profiling::MetricCollector> collectors;
+    tvm::runtime::profiling::Report report = profile(collectors);
+
+    std::string rep_table = report->AsTable();
+    std::ofstream ofs_table (profile_table, std::ofstream::out);
+    ofs_table << rep_table << std::endl;
+    ofs_table.close();
+
+    std::string rep_csv = report->AsCSV();
+    std::ofstream ofs_csv (profile_csv, std::ofstream::out);
+    ofs_csv << rep_csv << std::endl;
+    ofs_csv.close();
+}
+
+void MeraDrpRuntimeWrapper::ProfileRun(const std::string& profile_table, const std::string& profile_csv, int freq_index) {
+    tvm::runtime::PackedFunc profile = mod.GetFunction("profile");
+    tvm::runtime::Array<tvm::runtime::profiling::MetricCollector> collectors;
+    tvm::runtime::profiling::Report report = profile(collectors, freq_index);
+
+    std::string rep_table = report->AsTable();
+    std::ofstream ofs_table (profile_table, std::ofstream::out);
+    ofs_table << rep_table << std::endl;
+    ofs_table.close();
+
+    std::string rep_csv = report->AsCSV();
+    std::ofstream ofs_csv (profile_csv, std::ofstream::out);
+    ofs_csv << rep_csv << std::endl;
+    ofs_csv.close();
+}
+
+int MeraDrpRuntimeWrapper::GetNumInput(std::string model_dir) {
+    // TVM does not support api to get number input of model.
+    // This function calculate input number base on convention
+    // of input data name (input_xyz.bin)
+    DIR *dir;
+    dirent *diread;
+    int num_input = 0;
+    if ((dir = opendir(model_dir.c_str())) != nullptr) {
+      while ((diread = readdir(dir)) != nullptr) {
+        std::string file_name(diread->d_name);
+        if (std::regex_match(file_name, std::regex("(input_)(.*)(bin)") )) {
+          num_input++;
+        }
+      }
+      closedir(dir);
+    } else {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Can not open model dir : %s", model_dir.c_str());
+    }
+
+    return num_input;
+}
+
+InOutDataType MeraDrpRuntimeWrapper::GetInputDataType(int index) {
+    tvm::runtime::PackedFunc get_input = mod.GetFunction("get_input");
+    tvm::runtime::NDArray input_info = get_input(index);
+    InOutDataType data_type = InOutDataType::OTHER;
+    if (input_info.DataType().is_float() && input_info.DataType().bits() == 32) {
+      data_type = InOutDataType::FLOAT32;
+    } else if (input_info.DataType().is_float() && input_info.DataType().bits() == 16) {
+      data_type = InOutDataType::FLOAT16;
+    }
+    return data_type;
+  }
+
+int MeraDrpRuntimeWrapper::GetNumOutput() {
+    return mod.GetFunction("get_num_outputs")();
+  }
+
+std::tuple<InOutDataType, void*, int64_t> MeraDrpRuntimeWrapper::GetOutput(int index) {
+    tvm::runtime::PackedFunc get_output = mod.GetFunction("get_output");
+    tvm::runtime::NDArray out = get_output(index);
+    int64_t out_size = 1;
+    for ( unsigned long i = 0; i < out.Shape().size(); ++i) {
+      out_size *= out.Shape()[i];
+    }
+
+    InOutDataType data_type = InOutDataType::OTHER;
+    if (out.DataType().is_float() && out.DataType().bits() == 32) {
+      data_type = InOutDataType::FLOAT32;
+    } else if (out.DataType().is_float() && out.DataType().bits() == 16) {
+      data_type = InOutDataType::FLOAT16;
+    }
+    return std::make_tuple(data_type, reinterpret_cast<void*>(out->data), out_size);
+}
diff --git a/darknet_drp_ros/src/MeraDrpRuntimeWrapper.h b/darknet_drp_ros/src/MeraDrpRuntimeWrapper.h
new file mode 100644
index 0000000..7f79d5f
--- /dev/null
+++ b/darknet_drp_ros/src/MeraDrpRuntimeWrapper.h
@@ -0,0 +1,54 @@
+/*
+ * Original Code (C) Copyright Edgecortix, Inc. 2022
+ * Modified Code (C) Copyright Renesas Electronics Corporation 2024ã€€
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+*/
+#include <tvm/runtime/module.h>
+
+enum class InOutDataType {
+  FLOAT32,
+  FLOAT16,
+  OTHER
+};
+
+class MeraDrpRuntimeWrapper {
+ public:
+  MeraDrpRuntimeWrapper();
+  ~MeraDrpRuntimeWrapper();
+
+  bool LoadModel(const std::string& model_dir, uint32_t start_address);
+  bool LoadModel(const std::string& model_dir, uint64_t start_address);
+  template <typename T>
+  void SetInput(int input_index, const T* data_ptr);
+  void Run();
+  void Run(int freq_index);
+  void ProfileRun(const std::string& profile_table, const std::string& profile_csv);
+  void ProfileRun(const std::string& profile_table, const std::string& profile_csv, int freq_index);
+  int GetNumInput(std::string model_dir);
+  InOutDataType GetInputDataType(int index);
+  int GetNumOutput();
+
+  std::tuple<InOutDataType, void*, int64_t> GetOutput(int index);
+
+ private:
+  int device_type;
+  int device_id;
+  tvm::runtime::Module mod;
+};
diff --git a/darknet_drp_ros/src/PreRuntime.h b/darknet_drp_ros/src/PreRuntime.h
new file mode 100644
index 0000000..48ef187
--- /dev/null
+++ b/darknet_drp_ros/src/PreRuntime.h
@@ -0,0 +1,473 @@
+/*
+ * Original Code (C) Copyright Renesas Electronics Corporation 2024
+ *ã€€
+ *  *1 DRP-AI TVM is powered by EdgeCortix MERA(TM) Compiler Framework.
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/***********************************************************************************************************************
+* File Name    : PreRuntime.h
+* Version      : 1.1.0
+* Description  : PreRuntime Header file
+***********************************************************************************************************************/
+#pragma once
+
+#ifndef PRERUNTIME_H
+#define PRERUNTIME_H
+/***********************************************************************************************************************
+* Include
+***********************************************************************************************************************/
+#include <linux/drpai.h>
+#include <iostream>
+#include <fstream>
+#include <cstdio>
+#include <string>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <termios.h>
+#include <errno.h>
+#include <vector>
+#include <map>
+#include <fstream>
+#include <iostream>
+#include <iomanip>
+#include <string>
+#include <unordered_map>
+#include <cstring>
+#include <float.h>
+#include <signal.h>
+#include <cmath>
+
+#include <builtin_fp16.h>
+/***********************************************************************************************************************
+* Macro
+***********************************************************************************************************************/
+#define BUF_SIZE        (1024)
+#define NUM_OBJ_FILE    (6)
+#define INDEX_I         (0)
+#define INDEX_D         (1)
+#define INDEX_C         (2)
+#define INDEX_P         (3)
+#define INDEX_A         (4)
+#define INDEX_W         (5)
+#define DRPAI_TIMEOUT   (5)
+
+/*Uncomment to enable displaying the debug console log*/
+// #define DEBUG_LOG
+
+/*Error List*/
+#define PRE_SUCCESS         (0)
+#define PRE_ERROR           (1)
+#define PRE_ERROR_UI        (-1)
+
+/* Library Name */
+#define LIB_CONVYUV2RGB     ("conv_yuv2rgb")
+#define LIB_RESIZE_HWC      ("resize_hwc")
+#define LIB_IMAGESCALER     ("imagescaler")
+#define LIB_TRANSPOSE       ("transpose")
+#define LIB_CASTFP16_FP32   ("cast_fp16_fp32")
+#define LIB_CONVX2GRAY      ("conv_x2gray")
+#define LIB_CROP            ("crop")
+#define LIB_ARGMINMAX       ("argminmax")
+
+/* Param Info ID */
+#define OP_HEAD             ("OFFSET_ADD:")
+#define OP_LAYER_NAME       ("layer_name:")
+#define OP_LIB              ("drp_lib:")
+#define PRAM_HEAD           ("Param:")
+#define PARAM_VALUE         ("Value:")
+#define PARAM_OFFSET        ("offset:")
+#define PARAM_SIZE          ("size:")
+
+/* Param name */
+#define P_RADDR             ("raddr")
+#define P_WADDR             ("waddr")
+#define P_IMG_IWIDTH        ("IMG_IWIDHT")
+#define P_IMG_IHEIGHT       ("IMG_IHEIGHT")
+#define P_IMG_OWIDTH        ("IMG_OWIDTH")
+#define P_IMG_OHEIGHT       ("IMG_OHEIGHT")
+#define P_INPUT_YUV_FORMAT  ("INPUT_YUV_FORMAT")
+#define P_DOUT_RGB_FORMAT   ("DOUT_RGB_FORMAT")
+#define P_RESIZE_ALG        ("RESIZE_ALG")
+#define P_DATA_TYPE         ("DATA_TYPE")
+#define P_ADD_ADDR          ("ADD_ADDR")
+#define P_MUL_ADDR          ("MUL_ADDR")
+#define P_DOUT_RGB_ORDER    ("DOUT_RGB_ORDER")
+#define P_WORD_SIZE         ("WORD_SIZE")
+#define P_IS_CHW2HWC        ("IS_CHW2HWC")
+#define P_CAST_MODE         ("CAST_MODE")
+#define P_CROP_POS_X        ("CROP_POS_X")
+#define P_CROP_POS_Y        ("CROP_POS_Y")
+#define P_DIN_FORMAT        ("DIN_FORMAT")
+#define P_DOUT_RGB_FORMAT   ("DOUT_RGB_FORMAT")
+#define P_IMG_ICH           ("IMG_ICH")
+#define P_IMG_OCH           ("IMG_OCH")
+
+/* Other related values */
+#define FORMAT_YUYV_422     (0x0000)
+#define FORMAT_YVYU_422     (0x0001)
+#define FORMAT_UYUV_422     (0x0002)
+#define FORMAT_VUYY_422     (0x0003)
+#define FORMAT_YUYV_420     (0x1000)
+#define FORMAT_UYVY_420     (0x1001)
+#define FORMAT_YV12_420     (0x1002)
+#define FORMAT_IYUV_420     (0x1003)
+#define FORMAT_NV12_420     (0x1004)
+#define FORMAT_NV21_420     (0x1005)
+#define FORMAT_IMC1_420     (0x1006)
+#define FORMAT_IMC2_420     (0x1007)
+#define FORMAT_IMC3_420     (0x1008)
+#define FORMAT_IMC4_420     (0x1009)
+#define FORMAT_GRAY         (0xFFFC)
+#define FORMAT_BGR          (0xFFFD)
+#define FORMAT_RGB          (0xFFFE)
+#define FORMAT_UNKNOWN      (0xFFFF)
+
+/* Format in string. Only used when DEBUG_LOG is ON */
+#define FORMAT_YUYV_422_STR ("YUYV_422")
+#define FORMAT_YVYU_422_STR ("YVYU_422")
+#define FORMAT_UYUV_422_STR ("UYUV_422")
+#define FORMAT_VUYY_422_STR ("VUYY_422")
+#define FORMAT_YUYV_420_STR ("YVYU_420")
+#define FORMAT_UYVY_420_STR ("UYVY_420")
+#define FORMAT_YV12_420_STR ("YV12_420")
+#define FORMAT_IYUV_420_STR ("IYUV_420")
+#define FORMAT_NV12_420_STR ("NV12_420")
+#define FORMAT_NV21_420_STR ("NV21_420")
+#define FORMAT_IMC1_420_STR ("IMC1_420")
+#define FORMAT_IMC2_420_STR ("IMC2_420")
+#define FORMAT_IMC3_420_STR ("IMC3_420")
+#define FORMAT_IMC4_420_STR ("IMC4_420")
+#define FORMAT_GRAY_STR     ("GRAY")
+#define FORMAT_BGR_STR      ("BGR")
+#define FORMAT_RGB_STR      ("RGB")
+#define FORMAT_UNKNOWN_STR  ("UNKNOWN")
+/* Format in string. Only used when DEBUG_LOG is ON */
+static const std::unordered_map<uint16_t, std::string> format_string_table = 
+{ 
+    {FORMAT_YUYV_422, FORMAT_YUYV_422_STR},
+    {FORMAT_YVYU_422 , FORMAT_YVYU_422_STR},
+    {FORMAT_UYUV_422 , FORMAT_UYUV_422_STR},
+    {FORMAT_VUYY_422 , FORMAT_VUYY_422_STR},
+    {FORMAT_YUYV_420 , FORMAT_YUYV_420_STR},
+    {FORMAT_UYVY_420 , FORMAT_UYVY_420_STR},
+    {FORMAT_YV12_420 , FORMAT_YV12_420_STR},
+    {FORMAT_IYUV_420 , FORMAT_IYUV_420_STR},
+    {FORMAT_NV12_420 , FORMAT_NV12_420_STR},
+    {FORMAT_NV21_420 , FORMAT_NV21_420_STR},
+    {FORMAT_IMC1_420 , FORMAT_IMC1_420_STR},
+    {FORMAT_IMC2_420 , FORMAT_IMC2_420_STR},
+    {FORMAT_IMC3_420 , FORMAT_IMC3_420_STR},
+    {FORMAT_IMC4_420 , FORMAT_IMC4_420_STR},
+    {FORMAT_GRAY , FORMAT_GRAY_STR},
+    {FORMAT_BGR , FORMAT_BGR_STR},
+    {FORMAT_RGB , FORMAT_RGB_STR},
+    {FORMAT_UNKNOWN , FORMAT_UNKNOWN_STR}
+};
+
+/*If FORMAT_* >> BIT_YUV is 1, YUV420.
+  If 0, YUV422. 
+  >1 otherwise.*/
+#define BIT_YUV             (12)
+
+#define DIN_FORMAT_RGB      (0x1000)
+#define DIN_FORMAT_BGR      (0x1001)
+
+#define NUM_C_YUV           (2)
+#define NUM_C_RGB_BGR       (3)
+#define NUM_C_GRAY          (1)
+
+#define ALG_NEAREST         (0)
+#define ALG_BILINEAR        (1)
+#define INVALID_ADDR        (0xFFFFFFFF)
+#define INVALID_SHAPE       (0xFFFF)
+#define INVALID_FORMAT      (FORMAT_UNKNOWN)
+#define INVALID_RESIZE_ALG  (0xFF)
+
+#define MIN_INPUT_W_BOUND   (0)
+#define MIN_INPUT_H_BOUND   (0)
+#define MIN_RESIZE_W_BOUND  (2)
+#define MIN_RESIZE_H_BOUND  (2)
+#define MAX_RESIZE_W_BOUND  (4096)
+#define MAX_RESIZE_H_BOUND  (4096)
+#define MIN_CROP_W_BOUND    (0)
+#define MIN_CROP_H_BOUND    (0)
+
+#define MODE_PRE            (0)
+#define MODE_POST           (1)
+/***********************************************************************************************************************
+* Struct and related function
+***********************************************************************************************************************/
+
+/* For dynamic allocation support of DRP-AI Object files */
+typedef struct
+{
+    std::string   directory_name;
+    uint64_t      start_address;
+    unsigned long object_files_size;
+    unsigned long data_in_addr;
+    unsigned long data_in_size;
+    unsigned long data_out_addr;
+    unsigned long data_out_size;
+} st_drpai_data_t;
+
+typedef struct
+{
+    unsigned long desc_aimac_addr;
+    unsigned long desc_aimac_size;
+    unsigned long desc_drp_addr;
+    unsigned long desc_drp_size;
+    unsigned long drp_param_addr;
+    unsigned long drp_param_size;
+    unsigned long data_in_addr;
+    unsigned long data_in_size;
+    unsigned long data_addr;
+    unsigned long data_size;
+    unsigned long work_addr;
+    unsigned long work_size;
+    unsigned long data_out_addr;
+    unsigned long data_out_size;
+    unsigned long drp_config_addr;
+    unsigned long drp_config_size;
+    unsigned long weight_addr;
+    unsigned long weight_size;
+    unsigned long aimac_param_cmd_addr;
+    unsigned long aimac_param_cmd_size;
+    unsigned long aimac_param_desc_addr;
+    unsigned long aimac_param_desc_size;
+    unsigned long aimac_cmd_addr;
+    unsigned long aimac_cmd_size;
+} st_addr_info_t;
+
+
+typedef struct
+{
+    int             drpai_fd = -1;
+    st_drpai_data_t data_inout;
+    st_addr_info_t  drpai_address;
+} drpai_handle_t;
+
+typedef struct
+{
+    uint16_t pre_in_shape_w = INVALID_SHAPE;
+    uint16_t pre_in_shape_h = INVALID_SHAPE;
+    uint64_t pre_in_addr    = INVALID_ADDR;
+    uint16_t pre_in_format  = INVALID_FORMAT;
+    uint16_t pre_out_format = INVALID_FORMAT;
+    uint8_t resize_alg      = INVALID_RESIZE_ALG;
+    uint16_t resize_w       = INVALID_SHAPE;
+    uint16_t resize_h       = INVALID_SHAPE;
+    float cof_add[3]        = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
+    float cof_mul[3]        = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
+    uint16_t crop_tl_x      = INVALID_SHAPE;
+    uint16_t crop_tl_y      = INVALID_SHAPE;
+    uint16_t crop_w         = INVALID_SHAPE;
+    uint16_t crop_h         = INVALID_SHAPE;
+} s_preproc_param_t;
+
+typedef struct
+{
+    std::string name;
+    uint32_t value;
+    uint16_t offset;
+    uint16_t size;
+} s_op_param_t;
+
+typedef struct
+{
+    std::string name;
+    std::string lib;
+    uint16_t offset;
+    std::vector<s_op_param_t> param_list;
+} s_op_t;
+
+static void clear_param(s_op_param_t* data)
+{
+    data->name = "";
+    data->value = 0;
+    data->offset = 0;
+    data->size = 0;
+}
+
+static void clear_op(s_op_t* data)
+{
+    data->name = "";
+    data->lib = "";
+    data->offset = 0;
+    data->param_list.clear();
+}
+
+static std::string setW(std::string const &str, int n)
+{
+    std::ostringstream oss;
+    oss << std::left<<std::setw(n) << str;
+    return oss.str();
+}
+static void print_preproc_param(const s_preproc_param_t data, uint8_t mode=MODE_PRE)
+{
+    std::cout <<"PreProcessing Parameter List " <<std::endl;
+    std::cout <<"  pre_in_shape_w = "<<std::setw(8)<<std::dec<<data.pre_in_shape_w <<std::endl;
+    std::cout <<"  pre_in_shape_h = "<<std::setw(8)<<std::dec<<data.pre_in_shape_h <<std::endl;
+    std::cout <<"  pre_in_addr    = "<<std::setw(8)<<std::hex <<data.pre_in_addr <<std::endl;
+    if (!mode)
+    {
+        std::cout <<"  pre_in_format  = "<<std::setw(8)<<std::hex <<data.pre_in_format <<"("<<format_string_table.at(data.pre_in_format)<<")"<<std::endl;
+        std::cout <<"  pre_out_format = "<<std::setw(8)<<std::hex <<data.pre_out_format <<"("<<format_string_table.at(data.pre_out_format)<<")"<<std::endl;
+        std::cout <<"  resize_alg     = "<<std::setw(8)<<std::dec <<(int) data.resize_alg <<std::endl;
+        std::cout <<"  resize_w       = "<<std::setw(8)<<std::dec <<(int) data.resize_w <<std::endl;
+        std::cout <<"  resize_h       = "<<std::setw(8)<<std::dec <<(int) data.resize_h <<std::endl;
+        std::cout <<"  cof_add        = ";
+        std::cout << std::fixed<<std::setw(5)<<std::setprecision(4)<<(float)data.cof_add[0];
+        if (FORMAT_GRAY !=data.pre_out_format)
+        {
+            std::cout <<", "<< std::setw(5)<<std::setprecision(4)<<(float)data.cof_add[1];
+            std::cout <<", "<< std::setw(5)<<std::setprecision(4)<<(float)data.cof_add[2];
+        }
+        std::cout << std::endl <<"  cof_mul        = ";
+        std::cout << std::fixed<<std::setw(5)<<std::setprecision(4)<<(float)data.cof_mul[0];
+        if (FORMAT_GRAY !=data.pre_out_format)
+        {
+            std::cout << ", "<<std::setw(5)<<std::setprecision(4)<<(float)data.cof_mul[1];
+            std::cout << ", "<<std::setw(5)<<std::setprecision(4)<<(float)data.cof_mul[2];
+        }
+        std::cout << std::endl;
+        std::cout <<"  crop_tl_x      = "<<std::setw(8)<<std::dec <<(int) data.crop_tl_x <<std::endl;
+        std::cout <<"  crop_tl_y      = "<<std::setw(8)<<std::dec <<(int) data.crop_tl_y <<std::endl;
+        std::cout <<"  crop_w         = "<<std::setw(8)<<std::dec <<(int) data.crop_w <<std::endl;
+        std::cout <<"  crop_h         = "<<std::setw(8)<<std::dec <<(int) data.crop_h <<std::endl;
+    }
+}
+
+/***********************************************************************************************************************
+* PreRuntime Class
+***********************************************************************************************************************/
+class PreRuntime {
+    public:
+        PreRuntime();
+        ~PreRuntime();
+
+        uint8_t Load(const std::string pre_dir, uint64_t start_addr);
+        uint8_t Load(const std::string pre_dir, uint32_t start_addr = INVALID_ADDR, uint8_t mode = MODE_PRE);
+        int     SetInput(void *indata);
+        uint8_t Pre(s_preproc_param_t* param, void** out_ptr, uint32_t* out_size);
+        uint8_t Pre(void** out_ptr, uint32_t* out_size, uint64_t phyaddr);
+        int     Occupied_size;
+
+    private:
+        /*Internal parameter value holder*/
+        s_preproc_param_t internal_param_val;
+        /*Internal output buffer*/
+        void* internal_buffer = NULL;
+        /*Internal output buffer size*/
+        uint32_t internal_buffer_size = 0;
+        /*DRP-AI Driver dynamic allocation function*/
+        drpai_handle_t drpai_obj_info;
+        drpai_data_t drpai_data0;
+        std::string obj_prefix = "pp";
+        /*Buffer to store drp_param.bin data*/
+        std::vector<uint8_t> param_data;
+        /*Buffer to store weight.dat data*/
+        std::vector<uint8_t> weight_data;
+        /*List to store parmeter information, i.e., address, offset, size.*/
+        std::vector<s_op_t> param_info;
+        uint8_t run_mode;
+        /*Variables for internal in/out information */
+        uint16_t pre_out_shape_w = (uint16_t) INVALID_SHAPE;
+        uint16_t pre_out_shape_h = (uint16_t) INVALID_SHAPE;
+        uint16_t pre_in_shape_c   = (uint16_t) FORMAT_UNKNOWN;
+        uint16_t pre_out_shape_c  = (uint16_t) FORMAT_UNKNOWN;
+        uint8_t pre_in_type_size  = 0;
+        uint8_t pre_out_type_size = 0;
+        /*Flags to figure out whether operators are included in Pre-Runtime Object files*/
+        bool crop_included      = false;
+        bool resize_included    = false;
+        bool normalize_included = false;
+        
+        /*Since ADRCONV cannot delete just any entry, a means to reconfigure everything became necessary.*/
+        uint64_t start_addr_v2h;
+        uint64_t mapped_in_addr_v2h;
+
+        /*Supported Format*/
+        const uint16_t supported_format_in[17] = 
+        { 
+            FORMAT_YUYV_422,
+            FORMAT_YVYU_422,
+            FORMAT_UYUV_422,
+            FORMAT_VUYY_422,
+            FORMAT_YUYV_420,
+            FORMAT_UYVY_420,
+            FORMAT_YV12_420,
+            FORMAT_IYUV_420,
+            FORMAT_NV12_420,
+            FORMAT_NV21_420,
+            FORMAT_IMC1_420,
+            FORMAT_IMC2_420,
+            FORMAT_IMC3_420,
+            FORMAT_IMC4_420,
+            FORMAT_GRAY,
+            FORMAT_RGB,
+            FORMAT_BGR 
+        };
+        const uint16_t supported_format_out[3] = 
+        { 
+            FORMAT_GRAY, 
+            FORMAT_RGB, 
+            FORMAT_BGR 
+        };
+        /*Functions*/
+        uint8_t ReadAddrmapTxt(std::string addr_file);
+        uint8_t WritePrerunData(const std::string dir);
+        uint8_t LoadFileToMemDynamic(std::string data, unsigned long offset, unsigned long size, uint32_t file_type);
+        uint8_t LoadFileToMemDynamic(std::string data, unsigned long offset, unsigned long size);
+        uint8_t LoadDataToMem(std::vector<uint8_t> *data, unsigned long from, unsigned long size);
+        uint8_t LoadDataToMem(std::vector<uint8_t> data, unsigned long from, unsigned long size);
+        uint8_t ReadFileData(std::vector<uint8_t> *data, std::string file, unsigned long size);
+        uint8_t ReadFileData(std::vector<uint8_t> &data, std::string file, unsigned long size);
+        uint8_t GetResult(unsigned long output_addr, unsigned long output_size);
+        uint8_t ParseParamInfo(const std::string info_file);
+        uint8_t LoadParamInfo();
+        uint8_t UpdateParamToDynamic(uint32_t start_addr);
+        
+        int8_t  UpdateParamData(const s_preproc_param_t param);
+        int8_t  UpdateWeightData(const s_preproc_param_t param);
+
+        void    UpdateInputShape(const uint16_t w, const uint16_t h);
+        void    UpdateResizeShape(const uint16_t w, const uint16_t h);
+        void    UpdateResizeAlg(const uint8_t val);
+        void    UpdateFormat(const uint16_t input_val, const uint16_t output_val);
+        uint8_t UpdateCoefficient(const float* cof_add, const float* cof_mul);
+        void    UpdateCropParam(const uint16_t tl_x, const uint16_t tl_y, const uint16_t w, const uint16_t h);
+
+        bool    IsDifferentFmInternal(const float* cof_add, const float* cof_mul);
+        void    WriteValue(uint16_t offset, uint32_t value, uint8_t size);
+        bool    IsInSupportedList(uint16_t format, uint8_t is_input);
+        bool    IsSupportedFormat(const s_preproc_param_t param, uint16_t format_in, uint16_t format_out);
+        uint32_t GetStartAddress(uint32_t addr, drpai_data_t drpai_data);
+        uint64_t GetStartAddress(uint64_t addr, drpai_data_t drpai_data);
+        bool    StartsWith(std::string str, std::string prefix);
+        double  timedifference_msec(struct timespec t0, struct timespec t1);
+};
+
+#endif //PRERUNTIME_H
diff --git a/darknet_drp_ros/src/PreRuntimeV2H.cpp b/darknet_drp_ros/src/PreRuntimeV2H.cpp
new file mode 100644
index 0000000..cf1370e
--- /dev/null
+++ b/darknet_drp_ros/src/PreRuntimeV2H.cpp
@@ -0,0 +1,869 @@
+/*
+ * Original Code (C) Copyright Renesas Electronics Corporation 2024
+ *ã€€
+ *  *1 DRP-AI TVM is powered by EdgeCortix MERA(TM) Compiler Framework.
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+/***********************************************************************************************************************
+* File Name    : PreRuntime.cpp
+* Version      : 1.1.0
+* Description  : PreRuntime Source file
+***********************************************************************************************************************/
+
+#include <fstream>
+#include <regex>
+#include <dirent.h>
+#include "PreRuntime.h"
+
+#include "rclcpp/rclcpp.hpp"
+
+PreRuntime::PreRuntime()
+{
+}
+
+PreRuntime::~PreRuntime()
+{
+    /*Free internal output buffer*/
+    if(NULL != internal_buffer)
+    {
+        free(internal_buffer);
+    }
+    /*Close DRP-AI Driver*/
+    if (0 <= drpai_obj_info.drpai_fd )
+    {
+        errno = 0;
+        if (PRE_SUCCESS != close(drpai_obj_info.drpai_fd ))
+        {
+            RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+                "[ERROR] Failed to close DRP-AI Driver : errno=%d", errno);
+        }
+    }
+}
+
+/*****************************************
+* Function Name : timedifference_msec
+* Description   : Function to compute the processing time in mili-seconds
+* Arguments     : t0 = processing start time
+*                 t1 = processing end time
+* Return value  : processing time in mili-seconds
+******************************************/
+double PreRuntime::timedifference_msec(struct timespec t0, struct timespec t1)
+{
+    return (t1.tv_sec - t0.tv_sec) * 1000.0 + (t1.tv_nsec - t0.tv_nsec) / 1000.0 / 1000.0;
+}
+
+/*****************************************
+* Function Name : ReadAddrmapTxt
+* Description   : Loads address and size of DRP-AI Object files into struct addr.
+* Arguments     : addr_file = filename of addressmap file (from DRP-AI Object files)
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::ReadAddrmapTxt(std::string addr_file)
+{
+    std::string str;
+    unsigned long l_addr = 0;
+    unsigned long l_size = 0;
+    std::string element, a, s;
+    errno = 0;
+
+    std::ifstream ifs(addr_file);
+    if (ifs.fail())
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to open Address Map List %s: errno=%d", addr_file.c_str(), errno);
+        return PRE_ERROR;
+    }
+
+    while(getline(ifs, str))
+    {
+        std::istringstream iss(str);
+        iss >> element >> a >> s;
+        l_addr = strtol(a.c_str(), NULL, 16);
+        l_size = strtol(s.c_str(), NULL, 16);
+
+        if ("drp_config" == element)
+        {
+            drpai_obj_info.drpai_address.drp_config_addr = l_addr;
+            drpai_obj_info.drpai_address.drp_config_size = l_size;
+
+        }
+        else if ("desc_aimac" == element || "aimac_desc" == element)
+        {
+            drpai_obj_info.drpai_address.desc_aimac_addr = l_addr;
+            drpai_obj_info.drpai_address.desc_aimac_size = l_size;      
+        }
+        else if ("desc_drp" == element || "drp_desc" == element)
+        {
+            drpai_obj_info.drpai_address.desc_drp_addr = l_addr;
+            drpai_obj_info.drpai_address.desc_drp_size = l_size;
+        }
+        else if ("drp_param" == element)
+        {
+            drpai_obj_info.drpai_address.drp_param_addr = l_addr;
+            drpai_obj_info.drpai_address.drp_param_size = l_size;
+        }
+        else if ("weight" == element)
+        {
+            drpai_obj_info.drpai_address.weight_addr = l_addr;
+            drpai_obj_info.drpai_address.weight_size = l_size;
+            
+        }
+        else if ("data_in" == element)
+        {
+            drpai_obj_info.drpai_address.data_in_addr = l_addr;
+            drpai_obj_info.drpai_address.data_in_size = l_size;
+        }
+        else if ("data" == element)
+        {
+            drpai_obj_info.drpai_address.data_addr = l_addr;
+            drpai_obj_info.drpai_address.data_size = l_size;
+        }
+        else if ("data_out" == element)
+        {
+            drpai_obj_info.drpai_address.data_out_addr = l_addr;
+            drpai_obj_info.drpai_address.data_out_size = l_size;
+        }
+        else if ("work" == element)
+        {
+            drpai_obj_info.drpai_address.work_addr = l_addr;
+            drpai_obj_info.drpai_address.work_size = l_size;
+        }
+        else if ("aimac_param_cmd" == element)
+        {
+            drpai_obj_info.drpai_address.aimac_param_cmd_addr = l_addr;
+            drpai_obj_info.drpai_address.aimac_param_cmd_size = l_size;
+        }
+        else if ("aimac_param_desc" == element)
+        {
+            drpai_obj_info.drpai_address.aimac_param_desc_addr = l_addr;
+            drpai_obj_info.drpai_address.aimac_param_desc_size = l_size;
+        }
+        else if ("aimac_cmd" == element)
+        {
+            drpai_obj_info.drpai_address.aimac_cmd_addr = l_addr;
+            drpai_obj_info.drpai_address.aimac_cmd_size = l_size;
+        }
+        else
+        {
+            /*Ignore other space*/
+        }
+
+    }
+
+    ifs.close();
+    return PRE_SUCCESS;
+}
+
+uint8_t PreRuntime::WritePrerunData(const std::string dir)
+{
+    std::string str;
+    std::string element, a, s;
+    uint8_t ret;
+    errno = 0;
+
+
+    std::vector<uint8_t> config_data;
+    std::string fname = dir+"/drp_config.mem";
+    ret = ReadFileData(&config_data, fname, drpai_obj_info.drpai_address.drp_config_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to read file %s/drp_config.mem", dir.c_str());
+        return PRE_ERROR;
+    }
+    /*Load weight data to memory using non-dynamic function.*/
+    ret = LoadDataToMem(&config_data, drpai_obj_info.drpai_address.drp_config_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.drp_config_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/drp_config.mem", dir.c_str());
+        return PRE_ERROR;
+    }
+
+
+    std::vector<uint8_t> aimac_desc_data;
+    ret = ReadFileData(&aimac_desc_data, dir+"/aimac_desc.bin", drpai_obj_info.drpai_address.desc_aimac_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to read file %s/aimac_desc.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    /*Load weight data to memory using non-dynamic function.*/
+    ret = LoadDataToMem(&aimac_desc_data, drpai_obj_info.drpai_address.desc_aimac_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.desc_aimac_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/aimac_desc.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    std::vector<uint8_t> drp_desc_data;
+    ret = ReadFileData(&drp_desc_data, dir+"/drp_desc.bin", drpai_obj_info.drpai_address.desc_drp_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to read file %s/drp_desc.bin", dir.c_str());
+       return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&drp_desc_data, drpai_obj_info.drpai_address.desc_drp_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.desc_drp_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/drp_desc.bin", dir.c_str());
+       return PRE_ERROR;
+    }
+       
+
+    std::vector<uint8_t> drp_param_data;
+    ret = ReadFileData(&drp_param_data, dir+"/drp_param.bin", drpai_obj_info.drpai_address.drp_param_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to read file %s/drp_param.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&drp_param_data, drpai_obj_info.drpai_address.drp_param_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.drp_param_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/drp_param.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    std::vector<uint8_t> weight_data;
+    ret = ReadFileData(&weight_data, dir+"/weight.bin", drpai_obj_info.drpai_address.weight_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to read file %s/weight.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&weight_data, drpai_obj_info.drpai_address.weight_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.weight_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/weight.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    std::vector<uint8_t> aimac_param_cmd_data;
+    ret = ReadFileData(&aimac_param_cmd_data, dir+"/aimac_param_cmd.bin", drpai_obj_info.drpai_address.aimac_param_cmd_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to read file %s/aimac_param_cmd.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&aimac_param_cmd_data, drpai_obj_info.drpai_address.aimac_param_cmd_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.aimac_param_cmd_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/aimac_param_cmd.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    std::vector<uint8_t> aimac_param_desc_data;
+    ret = ReadFileData(&aimac_param_desc_data, dir+"/aimac_param_desc.bin", drpai_obj_info.drpai_address.aimac_param_desc_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to read file %s/aimac_param_desc.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&aimac_param_desc_data, drpai_obj_info.drpai_address.aimac_param_desc_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.aimac_param_desc_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/aimac_param_desc.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+ 
+    std::vector<uint8_t> aimac_cmd_data;
+    ret = ReadFileData(&aimac_cmd_data, dir+"/aimac_cmd.bin", drpai_obj_info.drpai_address.aimac_cmd_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to read file %s/aimac_cmd.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+    ret = LoadDataToMem(&aimac_cmd_data, drpai_obj_info.drpai_address.aimac_cmd_addr + drpai_obj_info.data_inout.start_address, drpai_obj_info.drpai_address.aimac_cmd_size);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write file data %s/aimac_cmd.bin", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : LoadDataToMem
+* Description   : Loads a drp_param.bin to memory via DRP-AI Driver
+* Arguments     : data = filename to be written to memory
+*                 from = memory start address where the data is written
+*                 size = data size to be written
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::LoadDataToMem(std::vector<uint8_t> *data, unsigned long from, unsigned long size)
+{
+    int          drpai_fd = drpai_obj_info.drpai_fd;
+    drpai_data_t drpai_data;
+    uint8_t      ret = 0;
+
+    errno = 0;
+    drpai_data.address = from;
+    drpai_data.size    = size;
+    ret = ioctl(drpai_fd, DRPAI_ASSIGN, &drpai_data);
+    if ( -1 == ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to run DRPAI_ASSIGN : errno=%d", errno);
+        return PRE_ERROR;
+    }
+    ret = write(drpai_fd, data->data(), size);
+    if ( -1 == ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write with DRPAI_ASSIGN : errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : ReadFileData
+* Description   : Loads a drp_param.bin
+* Arguments     : data = container to store the file contents
+*                 file = filename to be read
+*                 size = data size to be read
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::ReadFileData(std::vector<uint8_t> *data, std::string file, unsigned long size)
+{
+    errno = 0;
+    data->resize(size);
+    data->clear();
+
+    std::ifstream ifs(file);
+    if (!ifs)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to open %s: errno=%d", file.c_str(), errno);
+        return PRE_ERROR;
+    }
+
+    /* Store file data to internal vector */
+    std::istreambuf_iterator<char> it(ifs);
+    std::istreambuf_iterator<char> last;
+    for (; it != last; ++it)
+    {
+        data->push_back(*it);
+    }
+    /* Check the param_data size is appropriate */
+    if (size != data->size())
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to read %s: errno=%d", file.c_str(), errno);
+        return PRE_ERROR;
+    }
+    ifs.close();
+
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : ParseParamInfo
+* Description   : Loads a drp_param_info.txt.
+* Arguments     : info_file = filename to be loaded.
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::ParseParamInfo(const std::string info_file)
+{
+    const std::string offset_add      = OP_HEAD;
+    const std::string layer_name      = OP_LAYER_NAME;
+    const std::string drp_lib         = OP_LIB;
+    const std::string param_head      = PRAM_HEAD;
+    const std::string param_value     = PARAM_VALUE;
+    const std::string param_offset    = PARAM_OFFSET;
+    const std::string param_size      = PARAM_SIZE;
+    std::string str         = "";
+    std::string str_return  = "";
+    std::string element     = "";
+    std::string str_value   = "";
+    s_op_param_t tmp_param;
+    int  drpai_fd = drpai_obj_info.drpai_fd;
+    drpai_assign_param_t drpai_param;
+    uint32_t drp_param_info_size;
+    errno = 0;
+    
+    /*Get param info file size*/
+    std::ifstream param_file_for_size(info_file, std::ifstream::ate);
+    drp_param_info_size = static_cast<uint32_t>(param_file_for_size.tellg());
+    param_file_for_size.close();
+    drpai_param.info_size = drp_param_info_size;
+    drpai_param.obj.address = drpai_obj_info.drpai_address.drp_param_addr + drpai_obj_info.data_inout.start_address;
+    drpai_param.obj.size = drpai_obj_info.drpai_address.drp_param_size;
+    
+    if (0 != ioctl(drpai_fd, DRPAI_ASSIGN_PARAM, &drpai_param))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to run DRPAI_ASSIGN_PARAM : errno=%d %s %d", errno, __FILE__, __LINE__);
+        return PRE_ERROR;
+    }
+    
+    /* Open param info file */
+    std::vector<uint8_t> param_info_data;
+    int ret;
+    ret = ReadFileData(&param_info_data, info_file, drp_param_info_size);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to read file %s", info_file.c_str());
+        return PRE_ERROR;
+    }
+    uint8_t param_info_array[param_info_data.size()];
+    std::copy(param_info_data.begin(),param_info_data.end(),param_info_array);
+    if ( 0 > write(drpai_fd, param_info_array, drp_param_info_size))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), 
+            "[ERROR] Failed to write PARAM_INFO to DRP-AI Driver : errno=%d", errno);
+        return PRE_ERROR;
+    }
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : GetStartAddress
+* Description   : Check the user input start_addr is valid and return the valid address
+* Arguments     : addr = address to be checked.
+*               : drpai_data = DRP-AI memory area details.
+* Return value  : start address for Pre-Runtime Object files
+*                 INVALID_ADDR if user input is invalid
+******************************************/
+uint64_t PreRuntime::GetStartAddress(uint64_t addr, drpai_data_t drpai_data)
+{
+    uint64_t drpai_mem_addr_end = drpai_data.address+drpai_data.size - 1;
+    if (INVALID_ADDR == addr)
+    {
+        /*If user did not specify the start_addr, use DRP-AI memory area start address.*/
+        return drpai_data.address;
+    }
+    if ((drpai_data.address > addr)|| drpai_mem_addr_end < addr ) 
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Not in DRP-AI memory area.");
+        return INVALID_ADDR;
+    }
+    if (0 != (addr % 64))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Not 64-byte aligned.");
+        return INVALID_ADDR;
+    }
+    return addr;
+}
+
+/*****************************************
+* Function Name : Load
+* Description   : Loads PreRuntime Object data.
+* Arguments     : pre_dir = folder name to be loaded.
+*               : start_addr = start address that object files are dynamically allocated.
+*                              default value is INVALID_ADDR.
+*               : mode       = pre or post mode.
+*                              default value is MODE_PRE.
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::Load(const std::string pre_dir, uint32_t start_addr, uint8_t mode)
+{
+    return Load(pre_dir, (uint64_t)start_addr);
+}
+
+uint8_t PreRuntime::Load(const std::string pre_dir, uint64_t start_addr)
+{
+    uint8_t ret = 0;
+    struct stat statBuf;
+    std::string tmp_dir = "/";
+    std::string dir = pre_dir;
+    std::string tmp_address_file = dir+"/addr_map.txt";
+    const std::string drpai_param_file = dir + "/drp_param_info.txt";
+
+    /* Delete unnecessary slush */
+    if (dir.size() >= tmp_dir.size() &&
+            dir.find(tmp_dir, dir.size() - tmp_dir.size()) != std::string::npos)
+    {
+        dir = dir.erase(dir.size()-1);
+    }
+    /* Check whether directory exists*/
+    if (0 != stat(dir.c_str(),&statBuf))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Directory %s not found", dir.c_str());
+        return PRE_ERROR;
+    }
+
+    /*Check if PreRuntime Object files are generated from PreRuntime Compile Module*/
+    if (0 == stat(tmp_address_file.c_str(),&statBuf))
+    {
+        obj_prefix = dir;
+    }
+
+    /*Define necessary filename*/
+    const std::string address_file = dir+"/addr_map.txt";
+
+    errno = 0;
+    /*Open DRP-AI Driver*/
+    drpai_obj_info.drpai_fd = open("/dev/drpai0", O_RDWR);
+    if (PRE_SUCCESS > drpai_obj_info.drpai_fd )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to open DRP-AI Driver : errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    /* Get DRP-AI Memory Area Address via DRP-AI Driver */
+    ret = ioctl(drpai_obj_info.drpai_fd , DRPAI_GET_DRPAI_AREA, &drpai_data0);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to get DRP-AI Memory Area : errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    /* Read Address Map List file */
+    ret = ReadAddrmapTxt(address_file);
+    if (PRE_SUCCESS < ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to read Address Map List %s", address_file.c_str());
+        return PRE_ERROR;
+    }
+
+    if(start_addr == INVALID_ADDR)
+    {
+        this->Occupied_size = drpai_obj_info.drpai_address.desc_drp_addr + drpai_obj_info.drpai_address.desc_drp_size;
+        this->Occupied_size = (Occupied_size + 0xffffff) & 0xff000000;
+        start_addr = drpai_data0.address + drpai_data0.size - Occupied_size;
+    }
+    else
+    {
+        this->Occupied_size = drpai_data0.size - (start_addr - drpai_data0.address);
+    }
+
+    /* Set the DRP virtual start address to 0, indicating the actual 40-bit physical address. */
+    errno = 0;
+    drpai_adrconv_t drpai_adrconv;
+    this->start_addr_v2h = start_addr;
+    drpai_adrconv.conv_address = start_addr;
+    drpai_adrconv.org_address  = drpai_obj_info.drpai_address.data_in_addr; //Currently, data_in_addr contained the actual starting address.
+    drpai_adrconv.size         = this->Occupied_size;
+    drpai_adrconv.mode         = DRPAI_ADRCONV_MODE_REPLACE;
+    if ( PRE_SUCCESS != ioctl(drpai_obj_info.drpai_fd , DRPAI_SET_ADRCONV, &drpai_adrconv))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to run DRPAI_SET_ADRCONV : errno=%d", errno);
+       return PRE_ERROR;
+    }
+
+    /*Define the start address.*/
+    /*drpai_obj_info.drpai_address.data_in_addr maybe 0x00000000. */
+    drpai_obj_info.data_inout.start_address = drpai_adrconv.conv_address - drpai_obj_info.drpai_address.data_in_addr;
+
+    /*Parse drp_param_info.txt*/
+    ret = ParseParamInfo(drpai_param_file);
+    if ( PRE_SUCCESS < ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to read param info file: %s", drpai_param_file.c_str());
+        return PRE_ERROR;
+    }
+    
+    /*Write binary parameters for drpai.*/
+    ret = WritePrerunData(dir);
+    if ( PRE_SUCCESS != ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to write parameters. ");
+        return PRE_ERROR;
+    }
+
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : GetResult
+* Description   : Function to save the DRP-AI output. Uses DRP-AI Driver
+* Arguments     : output_ptr = pointer to the buffer which stores DRP-AI output
+*                 output_addr = memory address that DRP-AI output is stored.
+*                 output_size = memory size of DRP-AI output
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::GetResult(unsigned long output_addr, unsigned long output_size)
+{
+    int8_t ret = 0;
+    drpai_data_t drpai_data;
+    drpai_data.address = output_addr;
+    drpai_data.size = output_size;
+
+    /*Free internal buffer if its memory is already allocated */
+    if(internal_buffer != NULL )
+    {
+        free(internal_buffer);
+    }
+
+    internal_buffer = (uint32_t*) malloc(drpai_data.size);
+
+    if(internal_buffer == NULL)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to malloc PreRuntime internal buffer.");
+        return PRE_ERROR;
+    }
+    internal_buffer_size = (uint32_t) (drpai_data.size);
+
+    errno = 0;
+    /* Assign the memory address and size to be read */
+    ret = ioctl(drpai_obj_info.drpai_fd , DRPAI_ASSIGN, &drpai_data);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to run DRPAI_ASSIGN: errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    /* Read the memory via DRP-AI Driver and store the output to buffer */
+    errno = 0;
+    ret = read(drpai_obj_info.drpai_fd , internal_buffer, drpai_data.size);
+    if ( -1 == ret )
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to read via DRP-AI Driver: errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    return PRE_SUCCESS;
+}
+
+/*****************************************
+* Function Name : SetInput
+* Description   : 
+*                 
+* Arguments     : indata = pointer to input data
+*              
+* Return value  : true if succeeded
+*                 false error;
+******************************************/
+int PreRuntime::SetInput(void *indata)
+{
+    uint8_t ret = 0;
+    /* Write input data to data_in_addr.*/
+    drpai_data_t input;
+    input.address = drpai_obj_info.drpai_address.data_in_addr + drpai_obj_info.data_inout.start_address;
+    input.size    = drpai_obj_info.drpai_address.data_in_size;
+    ret = ioctl(drpai_obj_info.drpai_fd , DRPAI_ASSIGN, &input);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to run DRPAI_ASSIGN in SetInput(): errno=%d", errno);
+        return PRE_ERROR;
+    }
+    ret = write(drpai_obj_info.drpai_fd , indata, input.size);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to write via DRP-AI Driver in SetInput(): errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    return PRE_SUCCESS;
+}	
+
+/*****************************************
+* Function Name : Pre
+* Description   : Function to change paramter, run inference and get result.
+*                 To use this function, all param values must be defined.
+* Arguments     : param = pointer to parameter to be changed.
+*                 out_ptr = pointer to store output buffer starting pointer
+*                 out_size = size of output buffer
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+uint8_t PreRuntime::Pre(s_preproc_param_t* param, void** out_ptr, uint32_t* out_size)
+{
+    if((param->pre_in_addr & 0x800000000000) != 0)
+    {
+        /* Virtual address in linux user space */
+        SetInput((void *)param->pre_in_addr);
+
+        #ifndef WITH_V2H_DEV
+        return Pre(out_ptr, out_size, (uint64_t)(drpai_obj_info.drpai_address.data_in_addr + drpai_obj_info.data_inout.start_address));
+        #else
+        // If you don't have rzv2h-dev, don't care.
+        return Pre(out_ptr, out_size, (uint64_t)(drpai_obj_info.drpai_address.data_in_addr));
+        #endif
+    }
+    else
+    {
+
+        if(this->mapped_in_addr_v2h != param->pre_in_addr){
+	    int ret = 0;
+
+            drpai_adrconv_t drpai_adrconv;
+            drpai_adrconv.conv_address = this->start_addr_v2h;
+            drpai_adrconv.org_address  = drpai_obj_info.drpai_address.data_in_addr; //Currently, data_in_addr contained the actual starting address.
+            drpai_adrconv.size         = this->Occupied_size;
+            drpai_adrconv.mode         = DRPAI_ADRCONV_MODE_REPLACE;
+            ret = ioctl(drpai_obj_info.drpai_fd, DRPAI_SET_ADRCONV, &drpai_adrconv);
+            if (0 != ret)
+            {
+                RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+                    "[ERROR] Failed to run SET_ADRCONV(1) for DRP-AI input image : errno=%d", errno);
+                return PRE_ERROR;
+            }
+
+            this->mapped_in_addr_v2h = param->pre_in_addr;
+            drpai_adrconv.conv_address  = param->pre_in_addr & 0xffffff000000;
+            drpai_adrconv.org_address   = 0xD0000000;
+            drpai_adrconv.size          = 0x20000000; /*(drpai_obj_info.drpai_address.data_in_size + 0xffffff) & 0xff000000;*/
+            drpai_adrconv.mode          = DRPAI_ADRCONV_MODE_ADD;
+            ret = ioctl(drpai_obj_info.drpai_fd, DRPAI_SET_ADRCONV, &drpai_adrconv);
+    
+            if (0 != ret)
+            {
+                RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+                    "[ERROR] Failed to run SET_ADRCONV(2) for DRP-AI input image : errno=%d", errno);
+                return PRE_ERROR;
+            }
+        }
+
+        #ifndef WITH_V2H_DEV
+        return Pre(out_ptr, out_size, (uint64_t)param->pre_in_addr);
+        #else
+        // If you don't have rzv2h-dev, don't care.
+        return Pre(out_ptr, out_size, (uint64_t)0xD0000000);
+        #endif
+    }
+}
+
+uint8_t PreRuntime::Pre(void** out_ptr, uint32_t* out_size, uint64_t phyaddr)
+{
+    uint8_t ret = 0;
+    drpai_data_t proc[DRPAI_INDEX_NUM];
+    struct timespec ts_start, ts_end;
+    drpai_status_t drpai_status;
+    fd_set rfds;
+    struct timespec tv;
+    int8_t ret_drpai;
+    double preproc_time = 0;
+    sigset_t sigset;
+
+
+    sigemptyset(&sigset);
+    sigaddset(&sigset, SIGUSR1);
+
+    proc[DRPAI_INDEX_INPUT].address            = phyaddr;
+    proc[DRPAI_INDEX_INPUT].size               = drpai_obj_info.drpai_address.data_in_size;
+    proc[DRPAI_INDEX_DRP_CFG].address          = drpai_obj_info.drpai_address.drp_config_addr + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_DRP_CFG].size             = drpai_obj_info.drpai_address.drp_config_size;
+    proc[DRPAI_INDEX_DRP_PARAM].address        = drpai_obj_info.drpai_address.drp_param_addr  + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_DRP_PARAM].size           = drpai_obj_info.drpai_address.drp_param_size;
+    proc[DRPAI_INDEX_AIMAC_DESC].address       = drpai_obj_info.drpai_address.desc_aimac_addr + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_AIMAC_DESC].size          = drpai_obj_info.drpai_address.desc_aimac_size;
+    proc[DRPAI_INDEX_DRP_DESC].address         = drpai_obj_info.drpai_address.desc_drp_addr   + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_DRP_DESC].size            = drpai_obj_info.drpai_address.desc_drp_size;
+    proc[DRPAI_INDEX_WEIGHT].address           = drpai_obj_info.drpai_address.weight_addr     + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_WEIGHT].size              = drpai_obj_info.drpai_address.weight_size;
+    proc[DRPAI_INDEX_OUTPUT].address           = drpai_obj_info.drpai_address.data_out_addr   + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_OUTPUT].size              = drpai_obj_info.drpai_address.data_out_size;
+    proc[DRPAI_INDEX_AIMAC_CMD].address        = drpai_obj_info.drpai_address.aimac_param_cmd_addr   + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_AIMAC_CMD].size           = drpai_obj_info.drpai_address.aimac_param_cmd_size;
+    proc[DRPAI_INDEX_AIMAC_PARAM_DESC].address = drpai_obj_info.drpai_address.aimac_param_desc_addr   + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_AIMAC_PARAM_DESC].size    = drpai_obj_info.drpai_address.aimac_param_desc_size;
+    proc[DRPAI_INDEX_AIMAC_PARAM_CMD].address  = drpai_obj_info.drpai_address.aimac_cmd_addr   + drpai_obj_info.data_inout.start_address;
+    proc[DRPAI_INDEX_AIMAC_PARAM_CMD].size     = drpai_obj_info.drpai_address.aimac_cmd_size;
+
+#ifdef DEBUG_LOG
+    float diff = 0;
+    timespec_get(&ts_start, TIME_UTC);
+#endif
+
+    /* Wait till DRP-AI ends */
+    errno = 0;
+    if ( PRE_SUCCESS != ioctl(drpai_obj_info.drpai_fd , DRPAI_START, &proc[0]))
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to run DRPAI_START : errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    /* Wait till DRP-AI ends */
+    FD_ZERO(&rfds);
+    FD_SET(drpai_obj_info.drpai_fd , &rfds);
+    tv.tv_sec = 5;
+    tv.tv_nsec = 0;
+
+    ret_drpai = pselect(drpai_obj_info.drpai_fd +1, &rfds, NULL, NULL, &tv, &sigset);
+
+    if(0 == ret_drpai)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] DRP-AI timed out : errno=%d", errno);
+        return PRE_ERROR;
+    }
+    else if (-1 == ret_drpai)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+            "[ERROR] Failed to run DRP-AI Driver pselect : errno=%d", errno);
+        return PRE_ERROR;
+    }
+
+    if (FD_ISSET(drpai_obj_info.drpai_fd , &rfds))
+    {
+        errno = 0;
+        ret_drpai = ioctl(drpai_obj_info.drpai_fd, DRPAI_GET_STATUS, &drpai_status);
+        if (-1 == ret_drpai)
+        {
+            RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+                "[ERROR] Failed to run DRPAI_GET_STATUS : errno=%d", errno);
+            return PRE_ERROR;
+        }
+
+    }
+#ifdef DEBUG_LOG
+    /*Stop Timer */
+    timespec_get(&ts_end, TIME_UTC);
+    preproc_time = timedifference_msec(ts_start, ts_end);
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"),
+        "[TIME] PreRuntime DRP-AI processing time : %.2f msec", preproc_time);
+
+    timespec_get(&ts_start, TIME_UTC);
+#endif
+    /* Obtain result. Result is stored in internal_buffer */
+    ret = GetResult(proc[DRPAI_INDEX_OUTPUT].address, proc[DRPAI_INDEX_OUTPUT].size);
+    if (PRE_SUCCESS < ret)
+    {
+        RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[ERROR] Failed to get result.");
+        return PRE_ERROR;
+    }
+#ifdef DEBUG_LOG
+    timespec_get(&ts_end, TIME_UTC);
+    diff = timedifference_msec(ts_start, ts_end);
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "[TIME] GetResult() Processing Time : %.2f msec", diff);
+#endif
+
+    *out_ptr = internal_buffer;
+    *out_size = internal_buffer_size;
+
+    return PRE_SUCCESS;
+}
diff --git a/darknet_drp_ros/src/ascii.cpp b/darknet_drp_ros/src/ascii.cpp
new file mode 100644
index 0000000..0f0a855
--- /dev/null
+++ b/darknet_drp_ros/src/ascii.cpp
@@ -0,0 +1,116 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : ascii.cpp
+* Version      : 1.00
+* Description  : for RZ/V2H DRP-AI Sample Application with MIPI/USB Camera
+***********************************************************************************************************************/
+
+/*****************************************
+* Includes
+******************************************/
+/* ASCII header */
+#include "ascii.h"
+
+/*******************************************************************************
+* Global Tables
+*******************************************************************************/
+const char g_ascii_table[][6] =
+{
+  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},      /* ' '*/
+  { 0x00, 0x00, 0x79, 0x00, 0x00, 0x00},      /* ! */
+  { 0x00, 0x70, 0x00, 0x70, 0x00, 0x00},      /* " */
+  { 0x22, 0x7F, 0x22, 0x7F, 0x22, 0x00},      /* # */
+  { 0x12, 0x2A, 0x7F, 0x2A, 0x24, 0x00},      /* $ */
+  { 0x62, 0x64, 0x08, 0x13, 0x23, 0x00},      /* % */
+  { 0x36, 0x49, 0x55, 0x22, 0x05, 0x00},      /* & */
+  { 0x00, 0x00, 0x60, 0x00, 0x00, 0x00},      /* ' */
+  { 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00},      /* ( */
+  { 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00},      /* ) */
+  { 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00},      /* * */
+  { 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00},      /* + */
+  { 0x00, 0x05, 0x06, 0x00, 0x00, 0x00},      /* , */
+  { 0x08, 0x08, 0x08, 0x08, 0x08, 0x00},      /* - */
+  { 0x00, 0x03, 0x03, 0x00, 0x00, 0x00},      /* . */
+  { 0x02, 0x04, 0x08, 0x10, 0x20, 0x00},      /* / */
+  { 0x3E, 0x45, 0x49, 0x51, 0x3E, 0x00},      /* 0 */
+  { 0x00, 0x21, 0x7F, 0x01, 0x00, 0x00},      /* 1 */
+  { 0x21, 0x43, 0x45, 0x49, 0x71, 0x00},      /* 2 */
+  { 0x42, 0x41, 0x51, 0x69, 0x46, 0x00},      /* 3 */
+  { 0x0C, 0x14, 0x24, 0x7F, 0x04, 0x00},      /* 4 */
+  { 0x72, 0x51, 0x51, 0x51, 0x4E, 0x00},      /* 5 */
+  { 0x1E, 0x29, 0x49, 0x49, 0x06, 0x00},      /* 6 */
+  { 0x40, 0x47, 0x48, 0x50, 0x60, 0x00},      /* 7 */
+  { 0x36, 0x49, 0x49, 0x49, 0x36, 0x00},      /* 8 */
+  { 0x30, 0x49, 0x49, 0x4A, 0x3C, 0x00},      /* 9 */
+  { 0x00, 0x66, 0x66, 0x00, 0x00, 0x00},      /* : */
+  { 0x00, 0x35, 0x36, 0x00, 0x00, 0x00},      /* ; */
+  { 0x08, 0x14, 0x22, 0x41, 0x00, 0x00},      /* < */
+  { 0x14, 0x14, 0x14, 0x14, 0x14, 0x00},      /* = */
+  { 0x00, 0x41, 0x22, 0x14, 0x08, 0x00},      /* > */
+  { 0x20, 0x40, 0x45, 0x48, 0x30, 0x00},      /* ? */
+  { 0x38, 0x45, 0x5D, 0x59, 0x3E, 0x00},      /* @ */
+  { 0x1F, 0x24, 0x44, 0x24, 0x1F, 0x00},      /* A */
+  { 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00},      /* B */
+  { 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00},      /* C */
+  { 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00},      /* D */
+  { 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00},      /* E */
+  { 0x7F, 0x48, 0x48, 0x48, 0x40, 0x00},      /* F */
+  { 0x3E, 0x41, 0x49, 0x49, 0x2F, 0x00},      /* G */
+  { 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00},      /* H */
+  { 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00},      /* I */
+  { 0x02, 0x01, 0x41, 0x7E, 0x40, 0x00},      /* J */
+  { 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00},      /* K */
+  { 0x7F, 0x01, 0x01, 0x01, 0x01, 0x00},      /* L */
+  { 0x7F, 0x20, 0x18, 0x20, 0x7F, 0x00},      /* M */
+  { 0x7F, 0x10, 0x08, 0x04, 0x7F, 0x00},      /* N */
+  { 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00},      /* O */
+  { 0x7F, 0x48, 0x48, 0x48, 0x30, 0x00},      /* P */
+  { 0x3E, 0x41, 0x45, 0x42, 0x3D, 0x00},      /* Q */
+  { 0x7F, 0x48, 0x4C, 0x4A, 0x31, 0x00},      /* R */
+  { 0x32, 0x49, 0x49, 0x49, 0x26, 0x00},      /* S */
+  { 0x40, 0x40, 0x7F, 0x40, 0x40, 0x00},      /* T */
+  { 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x00},      /* U */
+  { 0x7C, 0x02, 0x01, 0x02, 0x7C, 0x00},      /* V */
+  { 0x7E, 0x01, 0x0E, 0x01, 0x7E, 0x00},      /* W */
+  { 0x63, 0x14, 0x08, 0x14, 0x63, 0x00},      /* X */
+  { 0x70, 0x08, 0x07, 0x08, 0x70, 0x00},      /* Y */
+  { 0x43, 0x45, 0x49, 0x51, 0x61, 0x00},      /* Z */
+  { 0x00, 0x7F, 0x41, 0x00, 0x00, 0x00},      /* [ */
+  { 0x20, 0x10, 0x08, 0x04, 0x02, 0x00},      /* "\" */
+  { 0x00, 0x00, 0x41, 0x7F, 0x00, 0x00},      /* ] */
+  { 0x00, 0x20, 0x40, 0x20, 0x00, 0x00},      /* ^ */
+  { 0x01, 0x01, 0x01, 0x01, 0x01, 0x00},      /* _ */
+  { 0x00, 0x40, 0x20, 0x00, 0x00, 0x00},      /* ' */
+  { 0x02, 0x15, 0x15, 0x0F, 0x01, 0x00},      /* a */
+  { 0x00, 0x7F, 0x11, 0x11, 0x0E, 0x00},      /* b */
+  { 0x00, 0x0E, 0x11, 0x11, 0x11, 0x00},      /* c */
+  { 0x0E, 0x11, 0x11, 0x7F, 0x00, 0x00},      /* d */
+  { 0x0E, 0x15, 0x15, 0x15, 0x0C, 0x00},      /* e */
+  { 0x00, 0x10, 0x3F, 0x50, 0x50, 0x00},      /* f */
+  { 0x08, 0x15, 0x15, 0x15, 0x1E, 0x00},      /* g */
+  { 0x00, 0x7F, 0x10, 0x10, 0x0F, 0x00},      /* h */
+  { 0x00, 0x11, 0x5F, 0x01, 0x00, 0x00},      /* i */
+  { 0x02, 0x01, 0x01, 0x5E, 0x00, 0x00},      /* j */
+  { 0x00, 0x7F, 0x04, 0x0A, 0x11, 0x00},      /* k */
+  { 0x00, 0x41, 0x7F, 0x01, 0x00, 0x00},      /* l */
+  { 0x1F, 0x10, 0x0F, 0x10, 0x0F, 0x00},      /* m */
+  { 0x00, 0x1F, 0x10, 0x10, 0x0F, 0x00},      /* n */
+  { 0x0E, 0x11, 0x11, 0x11, 0x0E, 0x00},      /* 0 */
+  { 0x1F, 0x14, 0x14, 0x14, 0x08, 0x00},      /* p */
+  { 0x08, 0x14, 0x14, 0x14, 0x1F, 0x00},      /* q */
+  { 0x00, 0x1F, 0x08, 0x10, 0x10, 0x00},      /* r */
+  { 0x09, 0x15, 0x15, 0x15, 0x12, 0x00},      /* s */
+  { 0x00, 0x10, 0x7E, 0x11, 0x01, 0x00},      /* t */
+  { 0x00, 0x1E, 0x01, 0x01, 0x1F, 0x00},      /* u */
+  { 0x1C, 0x02, 0x01, 0x02, 0x1C, 0x00},      /* v */
+  { 0x1E, 0x01, 0x06, 0x01, 0x1E, 0x00},      /* w */
+  { 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x00},      /* x */
+  { 0x18, 0x05, 0x05, 0x1E, 0x00, 0x00},      /* y */
+  { 0x11, 0x13, 0x15, 0x19, 0x11, 0x00},      /* z */
+  { 0x00, 0x08, 0x36, 0x41, 0x00, 0x00},      /* { */
+  { 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00},      /* | */
+  { 0x00, 0x41, 0x36, 0x08, 0x00, 0x00},      /* } */
+  { 0x00, 0x20, 0x40, 0x20, 0x40, 0x00}       /* ~ */
+  };
diff --git a/darknet_drp_ros/src/ascii.h b/darknet_drp_ros/src/ascii.h
new file mode 100644
index 0000000..387de75
--- /dev/null
+++ b/darknet_drp_ros/src/ascii.h
@@ -0,0 +1,20 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : ascii.h
+* Version      : 1.00
+* Description  : for RZ/V2H DRP-AI Sample Application with MIPI/USB Camera
+***********************************************************************************************************************/
+
+/* Multiple inclusion prevention macro */
+#ifndef ASCII_H
+#define ASCII_H
+
+/******************************************************************************
+Macro Definitions
+******************************************************************************/
+extern const char g_ascii_table[][6];
+
+/* ASCII_H */
+#endif
diff --git a/darknet_drp_ros/src/box.cpp b/darknet_drp_ros/src/box.cpp
new file mode 100644
index 0000000..8dab4d9
--- /dev/null
+++ b/darknet_drp_ros/src/box.cpp
@@ -0,0 +1,149 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : box.cpp
+* Version      : 1.00
+* Description  : For RZ/V2H DRP-AI Sample Application with MIPI/USB Camera
+***********************************************************************************************************************/
+
+/*****************************************
+* Includes
+******************************************/
+#include "box.h"
+
+/*****************************************
+* Function Name : overlap
+* Description   : Function to compute the overlapped data between coordinate x with size w
+* Arguments     : x1 = 1-dimensional coordinate of first line
+*                 w1 = size of fist line
+*                 x2 = 1-dimensional coordinate of second line
+*                 w2 = size of second line
+* Return value  : overlapped line size
+******************************************/
+float overlap(float x1, float w1, float x2, float w2)
+{
+    float l1 = x1 - w1/2;
+    float l2 = x2 - w2/2;
+    float left = l1 > l2 ? l1 : l2;
+    float r1 = x1 + w1/2;
+    float r2 = x2 + w2/2;
+    float right = r1 < r2 ? r1 : r2;
+    return right - left;
+}
+
+/*****************************************
+* Function Name : box_intersection
+* Description   : Function to compute the area of intersection of Box a and b
+* Arguments     : a = Box 1
+*                 b = Box 2
+* Return value  : area of intersection
+******************************************/
+float box_intersection(Box a, Box b)
+{
+    float w = overlap(a.x, a.w, b.x, b.w);
+    float h = overlap(a.y, a.h, b.y, b.h);
+    if(w < 0 || h < 0)
+    {
+        return 0;
+    }
+    float area = w*h;
+    return area;
+}
+
+/*****************************************
+* Function Name : box_union
+* Description   : Function to compute the area of union of Box a and b
+* Arguments     : a = Box 1
+*                 b = Box 2
+* Return value  : area of union
+******************************************/
+float box_union(Box a, Box b)
+{
+    float i = box_intersection(a, b);
+    float u = a.w*a.h + b.w*b.h - i;
+    return u;
+}
+
+/*****************************************
+* Function Name : box_iou
+* Description   : Function to compute the Intersection over Union (IoU) of Box a and b
+* Arguments     : a = Box 1
+*                 b = Box 2
+* Return value  : IoU
+******************************************/
+float box_iou(Box a, Box b)
+{
+    return box_intersection(a, b)/box_union(a, b);
+}
+
+/*****************************************
+* Function Name : filter_boxes_nms
+* Description   : Apply Non-Maximum Suppression (NMS) to get rid of overlapped rectangles.
+* Arguments     : det= detected rectangles
+*                 size = number of detections stored in det
+*                 th_nms = threshold for nms
+* Return value  : -
+******************************************/
+void filter_boxes_nms(std::vector<detection> &det, int32_t size, float th_nms)
+{
+    int32_t count = size;
+    int32_t i = 0;
+    int32_t j = 0;
+    Box a;
+    Box b;
+    float b_intersection = 0;
+
+    /** Interation for the comparision source */
+    for (i = 0; i < count; i++)
+    {
+        /** Skip i-th process if the comparision source is already suppressed. */
+        if ( 0 == det[i].prob )
+        {
+            continue;
+        }
+
+        /** Load the coordinate of the comparision source. */
+        a = det[i].bbox;
+        
+        /** Interation for the comparision destination.  */
+        for (j = i+1; j < count; j++)
+        {
+            /** Skip j-th process if the comparision destination is already suppressed */
+            if ( 0 == det[j].prob )
+            {
+                continue;
+            }
+
+            /** Skip j-th process if the classes between the source and destination are same. */
+            if (det[i].c != det[j].c)
+            {
+                continue;
+            }
+
+            /** Load the coordinate of the comparision source. */
+            b = det[j].bbox;
+
+            /** Suppression check with NMS algorithm. */
+            b_intersection = box_intersection(a, b);
+            if ((box_iou(a, b)>th_nms) || (b_intersection >= a.h * a.w - 1) || (b_intersection >= b.h * b.w - 1))
+            {
+                /** The one having the lesser probability will be suppressed */
+                if (det[i].prob > det[j].prob)
+                {
+                    /** Suppress the comparision destination. */
+                    det[j].prob= 0;
+                }
+                else
+                {
+                    /** Suppress the comparision source. */
+                    det[i].prob= 0;
+
+                    /** Skip the loop of comparision destination if the comparision source is suppressed. */
+                    break;
+                }
+            }
+        }
+    }
+    return;
+}
diff --git a/darknet_drp_ros/src/box.h b/darknet_drp_ros/src/box.h
new file mode 100644
index 0000000..3dfe71d
--- /dev/null
+++ b/darknet_drp_ros/src/box.h
@@ -0,0 +1,45 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : box.h
+* Version      : 1.00
+* Description  : For RZ/V2H DRP-AI Sample Application with MIPI/USB Camera
+***********************************************************************************************************************/
+
+#ifndef BOX_H
+#define BOX_H
+
+#include <vector>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+
+/*****************************************
+* Box : Bounding box coordinates and its size
+******************************************/
+typedef struct
+{
+    float x, y, w, h;
+} Box;
+
+/*****************************************
+* detection : Detected result
+******************************************/
+typedef struct detection
+{
+    Box bbox;
+    int32_t c;
+    float prob;
+} detection;
+
+/*****************************************
+* Functions
+******************************************/
+float box_iou(Box a, Box b);
+float overlap(float x1, float w1, float x2, float w2);
+float box_intersection(Box a, Box b);
+float box_union(Box a, Box b);
+void filter_boxes_nms(std::vector<detection> &det, int32_t size, float th_nms);
+
+#endif
diff --git a/darknet_drp_ros/src/define.h b/darknet_drp_ros/src/define.h
new file mode 100644
index 0000000..94eef33
--- /dev/null
+++ b/darknet_drp_ros/src/define.h
@@ -0,0 +1,240 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : define.h
+* Version      : 0.90
+* Description  : RZ/V2H DRP-AI Sample Application for Megvii-Base Detection YOLOX with MIPI/USB Camera
+***********************************************************************************************************************/
+
+#ifndef DEFINE_MACRO_H
+#define DEFINE_MACRO_H
+
+/*****************************************
+* includes
+******************************************/
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <vector>
+#include <map>
+#include <fstream>
+#include <math.h>
+#include <iomanip>
+#include <cstring>
+#include <float.h>
+#include <atomic>
+#include <semaphore.h>
+#include <numeric>
+/*****************************************
+* Macro for YOLOX
+******************************************/
+/* Input Camera support */
+/* n = 0: USB Camera, n = 1: eCAM22 */
+#define INPUT_CAM_TYPE 0
+
+/* Output Camera Size */
+#define CAM_INPUT_FHD
+#define IMAGE_OUTPUT_FHD
+#define MIPI_CAM_RES "1920x1080"
+
+/*Time Measurement Flag*/
+//#define DEBUG_TIME_FLG
+
+/*Display AI frame rate*/
+#define DISP_AI_FRAME_RATE
+
+/* Padding input mode to maintain the aspect ratio of DRP-AI input image.
+   This mode requires the DRP-AI object file having the squared input size CAM_IMAGE_WIDTH x CAM_IMAGE_WIDTH.
+   0: No padding, 
+   1: With padding (maintains the aspect ratio) */
+#define DRPAI_INPUT_PADDING (1)
+
+#if(1)  // TVM
+/* DRP-AI memory offset for model object file*/
+#define DRPAI_MEM_OFFSET            (0X38E0000)
+#endif  // TVM
+
+/*****************************************
+* Static Variables for YOLOX
+* Following variables need to be changed in order to custormize the AI model
+*  - drpai_prefix0 = directory name of DRP-AI Object files (DRP-AI Translator output)
+******************************************/
+/* Anchor box information */
+const static double anchors[] =
+{
+    1.08,   1.19,
+    3.42,   4.41,
+    6.63,   11.38,
+    9.42,   5.11,
+    16.62,  10.52
+};
+
+/*****************************************
+* Macro for YoloX
+******************************************/
+/* Number of class to be detected */
+#define NUM_CLASS                   (20)
+/* Number for [region] layer num parameter */
+#define NUM_BB                      (1)
+/* Number of output layers. This value MUST match with the length of num_grids[] below */
+#define NUM_INF_OUT_LAYER   (3)
+/* Number of grids in the image. The length of this array MUST match with the NUM_INF_OUT_LAYER */
+const static uint8_t num_grids[] = { 80,40,20 };
+/* Number of DRP-AI output */
+const static uint32_t num_inf_out =  (NUM_CLASS + 5) * NUM_BB * num_grids[0] * num_grids[0]
+                                + (NUM_CLASS + 5) * NUM_BB * num_grids[1] * num_grids[1]
+                                + (NUM_CLASS + 5) * NUM_BB * num_grids[2] * num_grids[2];/* Thresholds */
+
+#define TH_PROB                     (0.5f)
+#define TH_NMS                      (0.5f)
+/* Size of input image to the model */
+#define MODEL_IN_W                  (640)
+#define MODEL_IN_H                  (640)
+#define INPUT_W                    (640)
+#define INPUT_H                    (640)
+
+/*****************************************
+* Macro for Application
+******************************************/
+/*Maximum DRP-AI Timeout threshold*/
+#define DRPAI_TIMEOUT               (5)
+#if (1) // TVM
+/* DRP_MAX_FREQ and DRPAI_FREQ are the   */
+/* frequency settings for DRP-AI.        */
+/* Basically use the default values      */
+
+#define DRP_MAX_FREQ                (2)
+/* DRP_MAX_FREQ can be set from 2 to 127 */
+/* 2: 420MHz                             */
+/* 3: 315MHz                             */
+/* ...                                   */
+/* 127: 9.84MHz                          */
+/* Calculation Formula:                  */
+/*     1260MHz /(DRP_MAX_FREQ + 1)       */
+
+#define DRPAI_FREQ                  (2)
+/* DRPAI_FREQ can be set from 1 to 127   */
+/* 1,2: 1GHz                             */
+/* 3: 630MHz                             */
+/* 4: 420MHz                             */
+/* 5: 315MHz                             */
+/* ...                                   */
+/* 127: 10MHz                            */
+/* Calculation Formula:                  */
+/*     1260MHz /(DRPAI_FREQ - 1)         */
+/*     (When DRPAI_FREQ = 3 or more.)    */
+#endif  // TVM
+
+/*Camera:: Capture Image Information*/
+#ifdef CAM_INPUT_VGA
+#define CAM_IMAGE_WIDTH             (640)
+#define CAM_IMAGE_HEIGHT            (480)
+#else /* CAM_INPUT_FHD */
+#define CAM_IMAGE_WIDTH             (1920)
+#define CAM_IMAGE_HEIGHT            (1080)
+#endif
+
+#define CAM_IMAGE_CHANNEL_YUY2      (2)
+#define CAM_IMAGE_SIZE              (CAM_IMAGE_WIDTH * CAM_IMAGE_HEIGHT * CAM_IMAGE_CHANNEL_YUY2)
+
+/*Camera:: Capture Information */
+#if INPUT_CAM_TYPE == 1
+#define CAP_BUF_NUM                 (6)
+#define INPUT_CAM_NAME              "MIPI Camera"
+#else /* INPUT_CAM_TYPE */
+#define CAP_BUF_NUM                 (3)
+#define INPUT_CAM_NAME              "USB Camera"
+#endif /* INPUT_CAM_TYPE */
+
+/*DRP-AI Input image information*/
+#if (1) == DRPAI_INPUT_PADDING
+/*** DRP-AI input is assigned to the buffer having the size of CAM_IMAGE_WIDTH^2 */
+#define DRPAI_IN_WIDTH              (CAM_IMAGE_WIDTH)
+#define DRPAI_IN_HEIGHT             (CAM_IMAGE_WIDTH) 
+#define DRPAI_IN_CHANNEL_YUY2       (CAM_IMAGE_CHANNEL_YUY2)
+#else
+/** DRP-AI input is assigned to the buffer having the size of camera image. */
+#define DRPAI_IN_WIDTH              (CAM_IMAGE_WIDTH)
+#define DRPAI_IN_HEIGHT             (CAM_IMAGE_HEIGHT)  
+#define DRPAI_IN_CHANNEL_YUY2       (CAM_IMAGE_CHANNEL_YUY2)
+#endif
+
+/*Wayland:: Wayland Information */
+#ifdef IMAGE_OUTPUT_HD
+#define IMAGE_OUTPUT_WIDTH          (1280)
+#define IMAGE_OUTPUT_HEIGHT         (720)
+#else /* IMAGE_OUTPUT_FHD */
+#define IMAGE_OUTPUT_WIDTH          (1920)
+#define IMAGE_OUTPUT_HEIGHT         (1080)
+#endif
+
+/*DRP-AI Input image information*/
+#ifdef CAM_INPUT_VGA
+#define DRPAI_OUT_WIDTH             (960)
+#define DRPAI_OUT_HEIGHT            (720)
+#else
+#define DRPAI_OUT_WIDTH             (IMAGE_OUTPUT_WIDTH)
+#define DRPAI_OUT_HEIGHT            (IMAGE_OUTPUT_HEIGHT)
+#endif
+
+#define IMAGE_CHANNEL_BGRA          (4)
+#define WL_BUF_NUM                  (2)
+
+/*input image memory area Information*/
+#define IMG_AREA_ORG_ADDRESS        (0xD0000000)    /* Note: Don't change this address */
+#define IMG_AREA_CNV_ADDRESS        (0x58000000)    /* CMA area start address used by mmngr */
+#define IMG_AREA_SIZE               (0x20000000)    /* CMA area size */
+
+/* Image buffer size */
+#define IMAGEBUF                    (IMAGE_OUTPUT_WIDTH * IMAGE_OUTPUT_HEIGHT * IMAGE_CHANNEL_BGRA)
+/* DRP-AI Input image buffer size */
+#if (1) == DRPAI_INPUT_PADDING
+#define DRPAIBUF                    (CAM_IMAGE_WIDTH * CAM_IMAGE_WIDTH * CAM_IMAGE_CHANNEL_YUY2)
+#else   /* (1) == DRPAI_INPUT_PADDING */
+#define DRPAIBUF                    (CAM_IMAGE_WIDTH * CAM_IMAGE_HEIGHT * CAM_IMAGE_CHANNEL_YUY2)
+#endif  /* (1) == DRPAI_INPUT_PADDING */
+
+/*Image:: Text information to be drawn on image*/
+#define CHAR_SCALE_LARGE            (0.8)
+#define CHAR_SCALE_SMALL            (0.7)
+#define CHAR_THICKNESS              (2)
+#define LINE_HEIGHT                 (30) /*in pixel*/
+#define LINE_HEIGHT_OFFSET          (20) /*in pixel*/
+#define TEXT_WIDTH_OFFSET           (10) /*in pixel*/
+#define BOX_LINE_SIZE               (3)  /*in pixel*/
+#define BOX_HEIGHT_OFFSET           (30) /*in pixel*/
+#define BOX_TEXT_HEIGHT_OFFSET      (8)  /*in pixel*/
+#define CHAR_SCALE_FONT             (0.8)
+#define WHITE_DATA                  (0xFFFFFFu) /* in RGB */
+#define BLACK_DATA                  (0x000000u)
+
+/*Waiting Time*/
+#define WAIT_TIME                   (1000) /* microseconds */
+
+/*Timer Related*/
+#define CAPTURE_TIMEOUT             (20)  /* seconds */
+#define AI_THREAD_TIMEOUT           (20)  /* seconds */
+#define DISPLAY_THREAD_TIMEOUT      (20)  /* seconds */
+#define KEY_THREAD_TIMEOUT          (5)   /* seconds */
+#define TIME_COEF                   (1)
+
+/*Buffer size for writing data to memory via DRP-AI Driver.*/
+#define BUF_SIZE                    (1024)
+
+/*Array size*/
+#define SIZE_OF_ARRAY(array) (sizeof(array)/sizeof(array[0]))
+
+/*****************************************
+* For image.cpp
+******************************************/
+/*For drawing the bounding box label on image*/
+#define FONTDATA_WIDTH              (6)
+#define FONTDATA_HEIGHT             (8)
+
+#endif
diff --git a/darknet_drp_ros/src/define_color_yolox.h b/darknet_drp_ros/src/define_color_yolox.h
new file mode 100644
index 0000000..35f30c8
--- /dev/null
+++ b/darknet_drp_ros/src/define_color_yolox.h
@@ -0,0 +1,67 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : define_color.h
+* Version      : 1.00
+* Description  : RZ/V2H DRP-AI Sample Application for Megvii-Base Detection YOLOX with MIPI/USB Camera
+***********************************************************************************************************************/
+#ifndef DEFINE_COLOR_H
+#define DEFINE_COLOR_H
+
+/*****************************************
+* color
+******************************************/
+/* Pascal VOC dataset label list */
+const static std::vector<std::string> label_file_map = 
+{ 
+    "aeroplane",
+    "bicycle",
+    "bird",
+    "boat",
+    "bottle",
+    "bus",
+    "car",
+    "cat",
+    "chair",
+    "cow",
+    "diningtable",
+    "dog",
+    "horse",
+    "motorbike",
+    "person",
+    "pottedplant", 
+    "sheep",
+    "sofa",
+    "train",
+    "tvmonitor" 
+};
+
+/* box color list */
+const static unsigned int box_color[] =
+{
+    (0xFFFF00u),
+    (0xFF0000u),
+    (0xC0C0C0u),
+    (0xFFA07Au),
+    (0xFF1493u),
+    (0x006400u),
+    (0x00BFFFu),
+    (0xDAA520u),
+    (0xFF00FFu),
+    (0xFFC0CBu),
+    (0x008000u),
+    (0x800080u),
+    (0xFFA500u),
+    (0x1E90FFu),
+    (0x7CFC00u),
+    (0xF000F0u),
+    (0xF000FFu),
+    (0xFF00FFu),
+    (0xFF00FFu),
+    (0xFF0FFFu)
+};
+
+
+#endif
+
diff --git a/darknet_drp_ros/src/image_yolox.cpp b/darknet_drp_ros/src/image_yolox.cpp
new file mode 100644
index 0000000..50c3ba7
--- /dev/null
+++ b/darknet_drp_ros/src/image_yolox.cpp
@@ -0,0 +1,573 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : image.cpp
+* Version      : 1.00
+* Description  : RZ/V2H DRP-AI Sample Application for YOLO* with MIPI/USB Camera
+***********************************************************************************************************************/
+
+/*****************************************
+* Includes
+******************************************/
+#include "image_yolox.h"
+#include <opencv2/opencv.hpp>
+
+#include "rclcpp/rclcpp.hpp"
+#include "rclcpp_action/rclcpp_action.hpp"
+#include "std_msgs/msg/header.hpp"
+#include "sensor_msgs/msg/image.hpp"
+#include "geometry_msgs/msg/point.hpp"
+#include "image_transport/image_transport.hpp"
+
+Image::Image()
+{
+
+}
+
+
+Image::~Image()
+{
+
+}
+
+/*****************************************
+* Function Name : get_H
+* Description   : Function to get the image height
+*                 This function is NOT used currently.
+* Arguments     : -
+* Return value  : img_h = current image height
+******************************************/
+uint32_t Image::get_H()
+{
+    return img_h;
+}
+
+
+/*****************************************
+* Function Name : get_W
+* Description   : Function to get the image width
+*                 This function is NOT used currently.
+* Arguments     : -
+* Return value  : img_w = current image width
+******************************************/
+uint32_t Image::get_W()
+{
+    return img_w;
+}
+
+
+/*****************************************
+* Function Name : get_C
+* Description   : Function to set the number of image channel
+*                 This function is NOT used currently.
+* Arguments     : c = new number of image channel to be set
+* Return value  : -
+******************************************/
+uint32_t Image::get_C()
+{
+    return img_c;
+}
+
+/*****************************************
+* Function Name : get_img
+* Description   : Function to return the camera buffer
+* Arguments     : -
+* Return value  : camera buffer
+******************************************/
+uint8_t* Image::get_img(uint8_t id)
+{
+    return img_buffer[id];
+}
+
+uint8_t* Image::get_overlay_img(uint8_t id)
+{
+    return overlay_buffer[id];
+}
+
+
+/*****************************************
+* Function Name : init
+* Description   : Function to initialize img_buffer in Image class
+*                 This application uses udmabuf in order to
+*                 continuous memory area for DRP-AI input data
+* Arguments     : w = input image width in YUYV
+*                 h = input image height in YUYV
+*                 c = input image channel in YUYV
+*                 ow = output image width in BGRA to be displayed via Wayland
+*                 oh = output image height in BGRA to be displayed via Wayland
+*                 oc = output image channel in BGRA to be displayed via Wayland
+*                 mem = pointer to the memory for the display buffer
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+
+uint8_t Image::init(uint32_t w, uint32_t h, uint32_t c,
+                    uint32_t ow, uint32_t oh, uint32_t oc, void *mem)
+{
+    int32_t i;
+    
+    /*Initialize input image information */
+    img_w = w;
+    img_h = h;
+    img_c = c;
+    /*Initialize output image information*/
+    out_w = ow;
+    out_h = oh;
+    out_c = oc;
+
+    uint32_t out_size = out_w * out_h * out_c;
+
+    for (i = 0; i < WL_BUF_NUM; i++)
+    {
+        img_buffer[i] =(unsigned char*)mem+(i*out_size);
+    }
+
+    return 0;
+}
+
+/*****************************************
+* Function Name : write_char
+* Description   : Display character in overlap buffer
+* Arguments     : code = code to be displayed
+*                 x = X coordinate to display character
+*                 y = Y coordinate to display character
+*                 color = character color
+* Return value  : -
+******************************************/
+void Image::write_char(char code,  uint32_t x,  uint32_t y, uint32_t color, uint32_t backcolor)
+{
+    uint32_t height;
+    uint32_t width;
+    char * p_pattern;
+    uint8_t mask = 0x80;
+
+    if ((code >= 0x20) && (code <= 0x7e))
+    {
+        p_pattern = (char *)&g_ascii_table[code - 0x20][0];
+    }
+    else
+    {
+        p_pattern = (char *)&g_ascii_table[10][0]; /* '*' */
+    }
+
+    /* Drawing */
+    for (height = 0; height < font_h; height++)
+    {
+        for (width = 0; width < font_w; width++)
+        {
+            if (p_pattern[width] & mask)
+            {
+                draw_point_yuyv( width + x, height + y , color );
+            }
+            else
+            {
+                draw_point_yuyv( width + x, height + y , backcolor );
+            }
+        }
+        mask = (uint8_t)(mask >> 1);
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : write_string_rgb
+* Description   : OpenCV putText() in RGB
+* Arguments     : str = string to be drawn
+*                 x = bottom left coordinate X of string to be drawn
+*                 y = bottom left coordinate Y of string to be drawn
+*                 scale = scale for letter size
+*                 color = letter color must be in RGB, e.g. white = 0xFFFFFF
+* Return Value  : -
+******************************************/
+void Image::write_string_rgb(std::string str, uint32_t align_type,  uint32_t x, uint32_t y, float scale, uint32_t color)
+{
+    uint8_t thickness = CHAR_THICKNESS;
+    /*Extract RGB information*/
+    uint8_t r = (color >> 16) & 0x0000FF;
+    uint8_t g = (color >>  8) & 0x0000FF;
+    uint8_t b = color & 0x0000FF;
+    int ptx = 0;
+    int pty = 0;
+    /*OpenCV image data is in BGRA */
+    cv::Mat bgra_image(out_h, out_w, CV_8UC4, img_buffer[buf_id]);
+
+    int baseline = 0;
+    cv::Size size = cv::getTextSize(str.c_str(), cv::FONT_HERSHEY_SIMPLEX, scale, thickness + 2, &baseline);
+    if (align_type == 1)
+    {
+        ptx = x;
+        pty = y;
+    }
+    else if (align_type == 2)
+    {
+        ptx = out_w - (size.width + x);
+        pty = y;
+    }
+    /*Color must be in BGR order*/
+    cv::putText(bgra_image, str.c_str(), cv::Point(ptx, pty), cv::FONT_HERSHEY_SIMPLEX, scale, cv::Scalar(0x00, 0x00, 0x00, 0xFF), thickness + 2);
+    cv::putText(bgra_image, str.c_str(), cv::Point(ptx, pty), cv::FONT_HERSHEY_SIMPLEX, scale, cv::Scalar(b, g, r, 0xFF), thickness);
+}
+/*****************************************
+* Function Name : write_string_rgb
+* Description   : OpenCV putText() in RGB
+* Arguments     : str = string to be drawn
+*                 x = bottom left coordinate X of string to be drawn
+*                 y = bottom left coordinate Y of string to be drawn
+*                 scale = scale for letter size
+*                 color = letter color must be in RGB, e.g. white = 0xFFFFFF
+* Return Value  : -
+******************************************/
+void Image::write_string_rgb_boundingbox(std::string str, uint32_t align_type,  uint32_t x_min, uint32_t y_min, uint32_t x_max, uint32_t y_max,float scale, uint32_t color)
+{
+    uint8_t thickness = CHAR_THICKNESS;
+    /*Extract RGB information*/
+    uint8_t r = (color >> 16) & 0x0000FF;
+    uint8_t g = (color >>  8) & 0x0000FF;
+    uint8_t b = color & 0x0000FF;
+	
+    int ptx = 0;
+    int pty = 0;
+    /*OpenCV image data is in BGRA */
+    cv::Mat bgra_image(out_h, out_w, CV_8UC4, img_buffer[buf_id]);
+
+    int baseline = 0;
+    cv::rectangle(bgra_image, cv::Point(x_min,y_min), cv::Point(x_max,y_max), cv::Scalar(b, g, r, 0xFF), BOX_LINE_SIZE);
+    
+    cv::Size size = cv::getTextSize(str.c_str(), cv::FONT_ITALIC, scale, thickness + 2, &baseline);
+    if (align_type == 1)
+    {
+        ptx = x_min;
+        pty = y_min;
+    }
+    else if (align_type == 2)
+    {
+        ptx = img_w - (size.width + x_min);
+        pty = y_min;
+    }
+    cv::rectangle(bgra_image, cv::Point(ptx-BOX_LINE_SIZE+1,pty-BOX_HEIGHT_OFFSET), cv::Point(ptx+size.width,pty), cv::Scalar(b, g, r, 0xFF), cv::FILLED);
+    /*Color must be in BGR order*/
+    cv::putText(bgra_image, str.c_str(), cv::Point(ptx, pty-BOX_TEXT_HEIGHT_OFFSET), cv::FONT_ITALIC, scale, cv::Scalar(0x00, 0x00, 0x00, 0xFF), thickness);
+}
+/*****************************************
+* Function Name : write_string
+* Description   : Display character string in overlap buffer
+* Arguments     : pcode = A pointer to the character string to be displayed
+*                 x = X coordinate to display character string
+*                 y = Y coordinate to display character string
+*                 color = character string color
+* Return Value  : -
+******************************************/
+void Image::write_string(const char * pcode, uint32_t x, uint32_t y, uint32_t color, uint32_t backcolor)
+{
+    uint32_t i;
+    uint32_t len = strlen(pcode);
+
+    x = x < 0 ? 2 : x;
+    x = (x > img_w - (i * font_w)) ? img_w - (i * font_w)-2 : x;
+    y = y < 0 ? 2 : y;
+    y = (y > img_h - font_h) ? img_h - font_h - 2 : y;
+
+    for (i = 0; i < len; i++)
+    {
+        write_char(pcode[i], (x + (i * font_w)), y, color, backcolor);
+    }
+
+    return;
+}
+
+/*****************************************
+* Function Name : draw_point_yuyv
+* Description   : Draw a single point on YUYV image
+* Arguments     : x = X coordinate to draw a point
+*                 y = Y coordinate to draw a point
+*                 color = point color
+* Return Value  : -
+******************************************/
+void Image::draw_point_yuyv(int32_t x, int32_t y, uint32_t color)
+{
+    uint32_t x0 = (uint32_t)x & ~0x1;
+
+    uint32_t draw_u = (color >> 8) & 0xFF;
+    uint32_t draw_v = (color >> 0) & 0xFF;
+
+    uint32_t target_u = img_buffer[buf_id][(y * img_w + x0) * img_c + 1];
+    uint32_t target_v = img_buffer[buf_id][(y * img_w + x0) * img_c + 3];
+
+    img_buffer[buf_id][(y * img_w + x0) * img_c + 1] = (draw_u + target_u) / 2;
+    img_buffer[buf_id][(y * img_w + x0) * img_c + 3] = (draw_v + target_v) / 2;
+
+    if ((x & 1) == 0)
+    {
+        img_buffer[buf_id][(y * img_w + x0) * img_c]     = (color >> 16) & 0xFF;
+    }
+    else
+    {
+        img_buffer[buf_id][(y * img_w + x0) * img_c + 2] = (color >> 16) & 0xFF;
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : draw_line
+* Description   : Draw a single line
+* Arguments     : x0 = X coordinate of a starting point
+*                 y0 = Y coordinate of a starting point
+*                 x1 = X coordinate of a end point
+*                 y1 = Y coordinate of a end point
+*                 color = line color
+* Return Value  : -
+******************************************/
+void Image::draw_line(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t color)
+{
+    int32_t dx = x1 - x0;
+    int32_t dy = y1 - y0;
+    int32_t sx = 1;
+    int32_t sy = 1;
+    float de;
+    int32_t i;
+
+    /* Change direction */
+    if (0 > dx)
+    {
+        dx *= -1;
+        sx *= -1;
+    }
+
+    if (0 > dy)
+    {
+        dy *= -1;
+        sy *= -1;
+    }
+
+    draw_point_yuyv(x0, y0, color);
+
+    if (dx > dy)
+    {
+        /* Horizontal Line */
+        for (i = dx, de = i / 2; i; i--)
+        {
+            x0 += sx;
+            de += dy;
+            if(de > dx)
+            {
+                de -= dx;
+                y0 += sy;
+            }
+            draw_point_yuyv(x0, y0, color);
+        }
+    }
+    else
+    {
+        /* Vertical Line */
+        for (i = dy, de = i / 2; i; i--)
+        {
+            y0 += sy;
+            de += dx;
+            if(de > dy)
+            {
+                de -= dy;
+                x0 += sx;
+            }
+            draw_point_yuyv(x0, y0, color);
+        }
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : draw_rect
+* Description   : Draw a rectangle
+* Arguments     : x = X coordinate of the center of rectangle
+*                 y = Y coordinate of the center of rectangle
+*                 w = width of the rectangle
+*                 h = height of the rectangle
+*                 str = string to label the rectangle
+* Return Value  : -
+******************************************/
+void Image::draw_rect(int32_t x, int32_t y, int32_t w, int32_t h, const char * str,uint32_t color)
+{
+    int32_t x_min = x - round(w / 2.);
+    int32_t y_min = y - round(h / 2.);
+    int32_t x_max = x + round(w / 2.) - 1;
+    int32_t y_max = y + round(h / 2.) - 1;
+    /* Check the bounding box is in the image range */
+    x_min = x_min < 1 ? 1 : x_min;
+    x_max = ((img_w - 2) < x_max) ? (img_w - 2) : x_max;
+    y_min = y_min < 1 ? 1 : y_min;
+    y_max = ((img_h - 2) < y_max) ? (img_h - 2) : y_max;
+
+    /* Draw the bounding box and class and probability*/
+    write_string_rgb_boundingbox(str,1,x_min, y_min,x_max,y_max,CHAR_SCALE_FONT,color);
+
+    return;
+}
+
+
+/*****************************************
+* Function Name : convert_format
+* Description   : Convert YUYV image to BGRA format
+* Arguments     : -
+* Return value  : -
+******************************************/
+void Image::convert_format()
+{
+#ifdef DEBUG_TIME_FLG
+    using namespace std;
+    chrono::system_clock::time_point start, end;
+    start = chrono::system_clock::now();
+#endif // DEBUG_TIME_FLG
+
+    uint8_t* pd = img_buffer[buf_id];
+    uint8_t buffer[img_w * img_h * out_c];
+    int pix_count = 0;
+    for (int i = 0; i < img_h * img_w / 2; i++)
+    {
+        int y0 = (int)pd[0] - 16;
+        int u0 = (int)pd[1] - 128;
+        int y1 = (int)pd[2] - 16;
+        int v0 = (int)pd[3] - 128;
+
+        pd += 4;
+        buffer[pix_count++] = Clip((298 * y0 + 516 * u0 + 128) >> 8); // blue
+        buffer[pix_count++] = Clip((298 * y0 - 100 * u0 - 208 * v0 + 128) >> 8); // green
+        buffer[pix_count++] = Clip((298 * y0 + 409 * v0 + 128) >> 8); // red
+        buffer[pix_count++] = 255;
+
+        buffer[pix_count++] = Clip((298 * y1 + 516 * u0 + 128) >> 8); // blue
+        buffer[pix_count++] = Clip((298 * y1 - 100 * u0 - 208 * v0 + 128) >> 8); // green
+        buffer[pix_count++] = Clip((298 * y1 + 409 * v0 + 128) >> 8); // red
+        buffer[pix_count++] = 255;
+    }
+    memcpy(img_buffer[buf_id], &buffer, img_w * img_h * out_c);
+
+#ifdef DEBUG_TIME_FLG
+    end = chrono::system_clock::now();
+    double time = static_cast<double>(chrono::duration_cast<chrono::microseconds>(end - start).count() / 1000.0);
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Convert YUYV To BGRA Time : %lf[ms]\n", time);
+#endif // DEBUG_TIME_FLG
+}
+
+uint8_t Image::Clip(int value)
+{
+    //unsigned char ret = (uint8_t)std::round(value);
+    if (value > 255)
+    {
+        value = 255;
+    }
+    if (value < 0)
+    {
+        value = 0;
+    }
+    return value;
+}
+
+
+/*****************************************
+* Function Name : convert_size
+* Description   : Scale down the input data (1920x1080) to the output data (1280x720) using OpenCV.
+* Arguments     : -
+* Return value  : -
+******************************************/
+void Image::convert_size(int in_w, int resize_w, bool is_padding)
+{
+    if (in_w == resize_w)
+    {
+        return;
+    }
+
+    cv::Mat org_image(img_h, img_w, CV_8UC4, img_buffer[buf_id]);
+    cv::Mat resize_image;
+    /* Resize */
+    cv::resize(org_image, resize_image, cv::Size(), 1.0 * resize_w / in_w, 1.0 * resize_w / in_w);
+	
+    if (is_padding)
+    {
+        cv::Mat dst_image;
+        copyMakeBorder(resize_image, dst_image, 0, 0, (out_w - resize_w) / 2, (out_w - resize_w) / 2, cv::BORDER_CONSTANT, cv::Scalar(0, 0, 0, 255));
+        memcpy(img_buffer[buf_id], dst_image.data, out_w * out_h * out_c);
+    }
+    else
+    {
+        memcpy(img_buffer[buf_id], resize_image.data, out_w * out_h * out_c);
+    }
+}
+
+/*****************************************
+* Function Name : camera_to_image
+* Description   : Function to copy the external image buffer data to img_buffer
+*                 This is only place where the buf_id is updated.
+* Arguments     : buffer = buffer to copy the image data
+*                 size = size of buffer
+* Return value  : none
+******************************************/
+void Image::camera_to_image(const uint8_t* buffer, int32_t size)
+{
+    /* Update buffer id */
+    buf_id = ++buf_id % WL_BUF_NUM;
+    memcpy(img_buffer[buf_id], buffer, sizeof(uint8_t)*size);
+}
+
+
+/*****************************************
+* Function Name : at
+* Description   : Get the value of img_buffer at index a.
+*                 This function is NOT used currently.
+* Arguments     : a = index of img_buffer
+* Return Value  : value of img_buffer at index a
+******************************************/
+uint8_t Image::at(int32_t a)
+{
+    return img_buffer[buf_id][a];
+}
+
+/*****************************************
+* Function Name : set
+* Description   : Set the value of img_buffer at index a.
+*                 This function is NOT used currently.
+* Arguments     : a = index of img_buffer
+*                 val = new value to be set
+* Return Value  : -
+******************************************/
+void Image::set(int32_t a, uint8_t val)
+{
+    img_buffer[buf_id][a] = val;
+    return;
+}
+/*****************************************
+* Function Name : get_buf_id
+* Description   : Get the value of the buf_id.
+* Arguments     : -
+* Return Value  : value of buf_id-
+******************************************/
+uint8_t Image::get_buf_id(void)
+{
+    return buf_id;
+}
+
+
+/*****************************************
+* Function Name : reset_overlay_img
+* Description   : -
+* Arguments     : -
+* Return Value  : -
+******************************************/
+void Image::reset_overlay_img()
+{
+#ifdef DEBUG_TIME_FLG
+    using namespace std;
+    chrono::system_clock::time_point start, end;
+    start = chrono::system_clock::now();
+#endif // DEBUG_TIME_FLG
+
+    cv::Mat src_image = cv::Mat::zeros(out_h, out_w, CV_8UC4);
+    uint8_t* dst = overlay_buffer[buf_id];
+    uint8_t* src = src_image.data;
+    memcpy(dst, src, out_w * out_h * out_c);
+
+#ifdef DEBUG_TIME_FLG
+    end = chrono::system_clock::now();
+    double time = static_cast<double>(chrono::duration_cast<chrono::microseconds>(end - start).count() / 1000.0);
+    RCLCPP_INFO(rclcpp::get_logger("darknet_drp_ros"), "Reset Overlay Buffer Time : %lf[ms]\n", time);
+#endif // DEBUG_TIME_FLG
+}
diff --git a/darknet_drp_ros/src/image_yolox.h b/darknet_drp_ros/src/image_yolox.h
new file mode 100644
index 0000000..008e9aa
--- /dev/null
+++ b/darknet_drp_ros/src/image_yolox.h
@@ -0,0 +1,65 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : image.h
+* Version      : 0.90
+* Description  : RZ/V2H DRP-AI Sample Application for Megvii-Base Detection YOLOX with MIPI/USB Camera
+***********************************************************************************************************************/
+
+#ifndef IMAGE_H
+#define IMAGE_H
+
+#include "define.h"
+#include "ascii.h"
+
+class Image
+{
+    public:
+        Image();
+        ~Image();
+
+        uint8_t* img_buffer[WL_BUF_NUM];
+        uint8_t* overlay_buffer[WL_BUF_NUM];
+        uint8_t get_buf_id();
+        void write_string_rgb(std::string str, uint32_t align_type, uint32_t x, uint32_t y, float size, uint32_t color);
+        void write_string_rgb_boundingbox(std::string str, uint32_t align_type,  uint32_t x_min, uint32_t y_min, uint32_t x_max, uint32_t y_max,float scale, uint32_t color);
+
+        uint32_t get_H();
+        uint32_t get_W();
+        uint32_t get_C();
+        uint8_t* get_img(uint8_t id);
+        uint8_t* get_overlay_img(uint8_t id);
+        uint8_t at(int32_t a);
+        void set(int32_t a, uint8_t val);
+
+        uint8_t init(uint32_t w, uint32_t h, uint32_t c, uint32_t ow, uint32_t oh, uint32_t oc, void *mem);
+        void draw_rect(int32_t x, int32_t y, int32_t w, int32_t h, const char* str,uint32_t color);
+        void reset_overlay_img();
+        void convert_format();
+        void convert_size(int in_w, int resize_w, bool is_padding);
+        void camera_to_image(const uint8_t* buffer, int32_t size);
+    private:
+        uint8_t buf_id = 0;
+
+        /* Input Image (YUYV from V4L2) Information */
+        uint32_t img_h;
+        uint32_t img_w;
+        uint32_t img_c;
+        /* Output Image (BGRA for Wayland) Information */
+        uint32_t out_h;
+        uint32_t out_w;
+        uint32_t out_c;
+
+        uint32_t front_color        = BLACK_DATA;
+        uint32_t back_color         = WHITE_DATA;
+        uint8_t font_w              = FONTDATA_WIDTH;
+        uint8_t font_h              = FONTDATA_HEIGHT;
+        void draw_point_yuyv(int32_t x, int32_t y, uint32_t color);
+        void draw_line(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t color);
+        void write_char(char code,  uint32_t x,  uint32_t y, uint32_t color, uint32_t backcolor);
+        void write_string(const char * pcode, uint32_t x, uint32_t y, uint32_t color, uint32_t backcolor);
+        uint8_t Clip(int value);
+};
+
+#endif
diff --git a/darknet_drp_ros/src/main.cpp b/darknet_drp_ros/src/main.cpp
new file mode 100644
index 0000000..ba4dcbf
--- /dev/null
+++ b/darknet_drp_ros/src/main.cpp
@@ -0,0 +1,1091 @@
+/***********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : main.cpp
+* Version      : 0.90
+* Description  : RZ/V2H DRP-AI Sample Application for Megvii-Base Detection YOLOX with MIPI/USB Camera
+***********************************************************************************************************************/
+
+/*****************************************
+* Includes
+******************************************/
+/*DRP-AI TVM[*1] Runtime*/
+#include "MeraDrpRuntimeWrapper.h"
+/*Pre-processing Runtime Header*/
+#include "PreRuntime.h"
+
+/*DRPAI Driver Header*/
+#include <linux/drpai.h>
+/*Definition of Macros & other variables*/
+#include "define.h"
+#include "define_color_yolox.h"
+/*Image control*/
+#include "image_yolox.h"
+/*box drawing*/
+#include "box.h"
+/*Mutual exclusion*/
+#include <mutex>
+#include <opencv2/opencv.hpp>
+#include <opencv2/imgproc/imgproc.hpp>
+#include <opencv2/highgui/highgui.hpp>
+#include <opencv2/objdetect/objdetect.hpp>
+#include <cv_bridge/cv_bridge.h>
+#include "main.h"
+
+using namespace std;
+namespace drpai
+{
+/*****************************************
+* Global Variables
+******************************************/
+/*Multithreading*/
+static mutex mtx;
+
+/*Flags*/
+static atomic<uint8_t> inference_start (0);
+
+/*Global Variables*/
+static float drpai_output_buf[num_inf_out];
+static uint64_t capture_address;
+static uint8_t buf_id;
+static Image img;
+
+/*AI Inference for DRPAI*/
+/* DRP-AI Driver file descriptor */
+static int g_drpai_fd0 = -1;
+/* DRP-AI TVM[*1] Runtime object */
+MeraDrpRuntimeWrapper runtime;
+/* Pre-processing Runtime object */
+PreRuntime preruntime;
+
+static double drpai_time = 0;
+#ifdef DISP_AI_FRAME_RATE
+static double ai_fps = 0;
+static double cap_fps = 0;
+static double proc_time_capture = 0;
+static uint32_t array_cap_time[30] = {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000};
+#endif /* DISP_AI_FRAME_RATE */
+static uint32_t disp_time = 0;
+static uint32_t array_drp_time[30] = {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000};
+static uint32_t array_disp_time[30] = {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000};
+
+static vector<detection> det;
+
+
+static double pre_time = 0;
+static double post_time = 0;
+static double ai_time = 0;
+
+/*****************************************
+* Function Name     : float16_to_float32
+* Description       : Function by Edgecortex. Cast uint16_t a into float value.
+* Arguments         : a = uint16_t number
+* Return value      : float = float32 number
+******************************************/
+float float16_to_float32(uint16_t a)
+{
+    return __extendXfYf2__<uint16_t, uint16_t, 10, float, uint32_t, 23>(a);
+}
+
+/*****************************************
+* Function Name : timedifference_msec
+* Description   : compute the time differences in ms between two moments
+* Arguments     : t0 = start time
+*                 t1 = stop time
+* Return value  : the time difference in ms
+******************************************/
+double DRPAINode::timedifference_msec(struct timespec t0, struct timespec t1)
+{
+    return (t1.tv_sec - t0.tv_sec) * 1000.0 + (t1.tv_nsec - t0.tv_nsec) / 1000000.0;
+}
+
+/*****************************************
+* Function Name : get_result
+* Description   : Get DRP-AI Output from memory via DRP-AI Driver
+* Arguments     : -
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int8_t DRPAINode::get_result()
+{
+    int8_t ret = 0;
+    int32_t i = 0;
+    int32_t output_num = 0;
+    std::tuple<InOutDataType, void*, int64_t> output_buffer;
+    int64_t output_size;
+    uint32_t size_count = 0;
+
+    /* Get the number of output of the target model. */
+    output_num = runtime.GetNumOutput();
+    size_count = 0;
+    /*GetOutput loop*/
+    for (i = 0;i<output_num;i++)
+    {
+        /* output_buffer below is tuple, which is { data type, address of output data, number of elements } */
+        output_buffer = runtime.GetOutput(i);
+        /*Output Data Size = std::get<2>(output_buffer). */
+        output_size = std::get<2>(output_buffer);
+
+        /*Output Data Type = std::get<0>(output_buffer)*/
+        if (InOutDataType::FLOAT16 == std::get<0>(output_buffer))
+        {
+            /*Output Data = std::get<1>(output_buffer)*/
+            uint16_t* data_ptr = reinterpret_cast<uint16_t*>(std::get<1>(output_buffer));
+
+            for (int j = 0; j<output_size; j++)
+            {
+                /*FP16 to FP32 conversion*/
+                drpai_output_buf[j + size_count]=float16_to_float32(data_ptr[j]);
+            }
+        }
+        else if (InOutDataType::FLOAT32 == std::get<0>(output_buffer))
+        {
+            /*Output Data = std::get<1>(output_buffer)*/
+            float* data_ptr = reinterpret_cast<float*>(std::get<1>(output_buffer));
+            for (int j = 0; j<output_size; j++)
+            {
+                drpai_output_buf[j + size_count]=data_ptr[j];
+            }
+        }
+        else
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Output data type : not floating point.");
+            ret = -1;
+            break;
+        }
+        size_count += output_size;
+    }
+    return ret;
+}
+
+/*****************************************
+* Function Name : sigmoid
+* Description   : Helper function for YOLO Post Processing
+* Arguments     : x = input argument for the calculation
+* Return value  : sigmoid result of input x
+******************************************/
+double DRPAINode::sigmoid(double x)
+{
+    return 1.0/(1.0 + exp(-x));
+}
+
+/*****************************************
+* Function Name : softmax
+* Description   : Helper function for YOLO Post Processing
+* Arguments     : val[] = array to be computed softmax
+* Return value  : -
+******************************************/
+void DRPAINode::softmax(float val[NUM_CLASS])
+{
+    float max_num = -FLT_MAX;
+    float sum = 0;
+    int32_t i;
+    for ( i = 0 ; i<NUM_CLASS ; i++ )
+    {
+        max_num = max(max_num, val[i]);
+    }
+
+    for ( i = 0 ; i<NUM_CLASS ; i++ )
+    {
+        val[i]= (float) exp(val[i] - max_num);
+        sum+= val[i];
+    }
+
+    for ( i = 0 ; i<NUM_CLASS ; i++ )
+    {
+        val[i]= val[i]/sum;
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : index
+* Description   : Get the index of the bounding box attributes based on the input offset.
+* Arguments     : n = output layer number.
+*                 offs = offset to access the bounding box attributesd.
+*                 channel = channel to access each bounding box attribute.
+* Return value  : index to access the bounding box attribute.
+******************************************/
+int32_t DRPAINode::index(uint8_t n, int32_t offs, int32_t channel)
+{
+    uint8_t num_grid = num_grids[n];
+    return offs + channel * num_grid * num_grid;
+}
+
+/*****************************************
+* Function Name : offset
+* Description   : Get the offset nuber to access the bounding box attributes
+*                 To get the actual value of bounding box attributes, use index() after this function.
+* Arguments     : n = output layer number [0~2].
+*                 b = Number to indicate which bounding box in the region [0~2]
+*                 y = Number to indicate which region [0~13]
+*                 x = Number to indicate which region [0~13]
+* Return value  : offset to access the bounding box attributes.
+******************************************/
+int32_t DRPAINode::offset(uint8_t n, int32_t b, int32_t y, int32_t x)
+{
+    uint8_t num = num_grids[n];
+    uint32_t prev_layer_num = 0;
+    int32_t i = 0;
+
+    for (i = 0 ; i < n; i++)
+    {
+        prev_layer_num += NUM_BB *(NUM_CLASS + 5)* num_grids[i] * num_grids[i];
+    }
+    return prev_layer_num + b *(NUM_CLASS + 5)* num * num + y * num + x;
+}
+
+/*****************************************
+* Function Name : R_Post_Proc
+* Description   : Process CPU post-processing for YoloX
+* Arguments     : floatarr = drpai output address
+* Return value  : -
+******************************************/
+void DRPAINode::R_Post_Proc(float* floatarr)
+{
+    /* Following variables are required for correct_region_boxes in Darknet implementation*/
+    /* Note: This implementation refers to the "darknet detector test" */
+    vector<detection> det_buff;
+    float new_w, new_h;
+    float correct_w = 1.;
+    float correct_h = 1.;
+    if ((float) (MODEL_IN_W / correct_w) < (float) (MODEL_IN_H/correct_h) )
+    {
+        new_w = (float) MODEL_IN_W;
+        new_h = correct_h * MODEL_IN_W / correct_w;
+    }
+    else
+    {
+        new_w = correct_w * MODEL_IN_H / correct_h;
+        new_h = MODEL_IN_H;
+    }
+
+    int32_t n = 0;
+    int32_t b = 0;
+    int32_t y = 0;
+    int32_t x = 0;
+    int32_t offs = 0;
+    int32_t i = 0;
+    float tx = 0;
+    float ty = 0;
+    float tw = 0;
+    float th = 0;
+    float tc = 0;
+    float center_x = 0;
+    float center_y = 0;
+    float box_w = 0;
+    float box_h = 0;
+    float objectness = 0;
+    uint8_t num_grid = 0;
+    uint8_t anchor_offset = 0;
+    float classes[NUM_CLASS];
+    float max_pred = 0;
+    int32_t pred_class = -1;
+    float probability = 0;
+    detection d;
+    //YOLOX
+    int stride = 0;
+    vector<int> strides = {8, 16, 32};
+
+    for (n = 0; n<NUM_INF_OUT_LAYER; n++)
+    {
+        num_grid = num_grids[n];
+        anchor_offset = 2 * NUM_BB * (NUM_INF_OUT_LAYER - (n + 1));
+
+        for (b = 0;b<NUM_BB;b++)
+        {
+           stride = strides[n];
+            for (y = 0;y<num_grid;y++)
+            {
+                for (x = 0;x<num_grid;x++)
+                {
+                    offs = offset(n, b, y, x);
+                    tc = floatarr[index(n, offs, 4)];
+
+                    objectness = tc;
+
+                    if (objectness > TH_PROB)
+                    {
+                        /* Get the class prediction */
+                        for (i = 0;i < NUM_CLASS;i++)
+                        {
+                            classes[i] = floatarr[index(n, offs, 5+i)];
+                        }
+
+                        max_pred = 0;
+                        pred_class = -1;
+                        for (i = 0; i < NUM_CLASS; i++)
+                        {
+                            if (classes[i] > max_pred)
+                            {
+                                pred_class = i;
+                                max_pred = classes[i];
+                            }
+                        }
+
+                        /* Store the result into the list if the probability is more than the threshold */
+                        probability = max_pred * objectness;
+                        if (probability > TH_PROB)
+                        {
+                            tx = floatarr[offs];
+                            ty = floatarr[index(n, offs, 1)];
+                            tw = floatarr[index(n, offs, 2)];
+                            th = floatarr[index(n, offs, 3)];
+
+                            /* Compute the bounding box */
+                            /*get_yolo_box/get_region_box in paper implementation*/
+                            center_x = (tx+ float(x))* stride;
+                            center_y = (ty+ float(y))* stride;
+                            center_x = center_x  / (float) MODEL_IN_W;
+                            center_y = center_y  / (float) MODEL_IN_H;
+                            box_w = exp(tw) * stride;
+                            box_h = exp(th) * stride;
+                            box_w = box_w / (float) MODEL_IN_W;
+                            box_h = box_h / (float) MODEL_IN_H;
+                            
+                            /* Adjustment for size */
+                            /* correct_yolo/region_boxes */
+                            center_x = (center_x - (MODEL_IN_W - new_w) / 2. / MODEL_IN_W) / ((float) new_w / MODEL_IN_W);
+                            center_y = (center_y - (MODEL_IN_H - new_h) / 2. / MODEL_IN_H) / ((float) new_h / MODEL_IN_H);
+                            box_w *= (float) (MODEL_IN_W / new_w);
+                            box_h *= (float) (MODEL_IN_H / new_h);
+
+                            center_x = round(center_x * DRPAI_IN_WIDTH);
+                            center_y = round(center_y * DRPAI_IN_HEIGHT);
+                            box_w = round(box_w * DRPAI_IN_WIDTH);
+                            box_h = round(box_h * DRPAI_IN_HEIGHT);
+                            
+                            Box bb = {center_x, center_y, box_w, box_h};
+                            d = {bb, pred_class, probability};
+                            det_buff.push_back(d);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    /* Non-Maximum Supression filter */
+    filter_boxes_nms(det_buff, det_buff.size(), TH_NMS);
+
+    /* Convert YUYV image to BGRA format.(bounding box algorithm require BGRA format) */
+    img.convert_format();
+
+    /* Draw bounding box on image. */
+    draw_bounding_box();
+
+    cv::Mat out_image(CAM_IMAGE_HEIGHT, CAM_IMAGE_WIDTH, CV_8UC4, img.img_buffer[0]);
+
+    /* Publish bounding box */
+    darknet_ros_msgs::msg::BoundingBoxes bounding_boxes_results;
+    int8_t seq = 0;
+    for (int32_t i = 0; i < det_buff.size(); i++)
+    {
+        if (det_buff[i].prob != 0)
+        {
+            darknet_ros_msgs::msg::BoundingBox bounding_box;
+            bounding_box.class_id = label_file_map[det_buff[i].c];
+            bounding_box.id = det_buff[i].c;
+            bounding_box.probability = det_buff[i].prob;
+            bounding_box.xmin = det_buff[i].bbox.x - round(det_buff[i].bbox.w / 2.);
+            bounding_box.ymin = det_buff[i].bbox.y - round(det_buff[i].bbox.h / 2.);
+            bounding_box.xmax = det_buff[i].bbox.x + round(det_buff[i].bbox.w / 2.) - 1;
+            bounding_box.ymax = det_buff[i].bbox.y + round(det_buff[i].bbox.h / 2.) - 1;
+
+            bounding_box.xmin = bounding_box.xmin < 1 ? 1 : bounding_box.xmin;
+            bounding_box.ymin = bounding_box.ymin < 1 ? 1 : bounding_box.ymin;
+            bounding_box.xmax = ((img.get_W() - 2) < bounding_box.xmax) ? (img.get_W() - 2) : bounding_box.xmax;
+            bounding_box.ymax = ((img.get_H() - 2) < bounding_box.ymax) ? (img.get_H() - 2) : bounding_box.ymax;
+            bounding_boxes_results.bounding_boxes.push_back(bounding_box);
+            seq++;
+        }
+    }
+    bounding_boxes_results.header.stamp = this->now();
+    bounding_boxes_results.header.frame_id = "detection";
+    bounding_boxes_results.image_header = image_header;
+    bounding_boxes_publisher->publish(bounding_boxes_results);
+
+    /* Publish object count */
+    darknet_ros_msgs::msg::ObjectCount msg;
+    msg.header.stamp = this->now();
+    msg.header.frame_id = "detection";
+    msg.count = seq;
+    object_publisher->publish(msg);
+
+    /* Publish detection image */
+    cv_bridge::CvImage cv_image;
+    cv_image.header.stamp = this->now();
+    cv_image.header.frame_id = "detection_image";
+    cv_image.encoding = "bgra8";
+    cv_image.image = out_image;
+    sensor_msgs::msg::Image ros_img;
+    cv_image.toImageMsg(ros_img);
+    detection_image_publisher->publish(ros_img);
+
+    mtx.lock();
+    /* Clear the detected result list */
+    det.clear();
+    copy(det_buff.begin(), det_buff.end(), back_inserter(det));
+    mtx.unlock();
+    return ;
+}
+
+/*****************************************
+* Function Name : draw_bounding_box
+* Description   : Draw bounding box on image.
+* Arguments     : -
+* Return value  : 0 if succeeded
+*               not 0 otherwise
+******************************************/
+void DRPAINode::draw_bounding_box(void)
+{
+    vector<detection> det_buff;
+    stringstream stream;
+    string result_str;
+    int32_t i = 0;
+    uint32_t color=0;
+ 
+    mtx.lock();
+    copy(det.begin(), det.end(), back_inserter(det_buff));
+    mtx.unlock();
+
+    /* Draw bounding box on RGB image. */
+    for (i = 0; i < det_buff.size(); i++)
+    {
+        /* Skip the overlapped bounding boxes */
+        if (det_buff[i].prob == 0) continue;
+        
+        color = box_color[det_buff[i].c];
+        /* Clear string stream for bounding box labels */
+        stream.str("");
+        /* Draw the bounding box on the image */
+        stream << fixed << setprecision(2) << det_buff[i].prob;
+        result_str = label_file_map[det_buff[i].c]+ " "+ stream.str();
+        img.draw_rect((int)det_buff[i].bbox.x, (int)det_buff[i].bbox.y, (int)det_buff[i].bbox.w, (int)det_buff[i].bbox.h, result_str.c_str(),color);
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : R_Inf_Thread
+* Description   : Executes the DRP-AI inference thread
+* Arguments     : none
+* Return value  : -
+******************************************/
+void *DRPAINode::R_Inf_Thread()
+{
+    /*Semaphore Variable*/
+    int32_t inf_sem_check = 0;
+    int32_t inf_cnt = -1;
+    
+    /*Variable for getting Inference output data*/
+    void* output_ptr;
+    uint32_t out_size;
+    /*Variable for Pre-processing parameter configuration*/
+    s_preproc_param_t in_param;
+
+    /*Variable for checking return value*/
+    int8_t ret = 0;
+    /*Variable for Performance Measurement*/
+
+    static struct timespec inf_start_time;
+    static struct timespec inf_end_time;
+    static struct timespec pre_start_time;
+    static struct timespec pre_end_time;
+    static struct timespec post_start_time;
+    static struct timespec post_end_time;
+    static struct timespec drp_prev_time = { .tv_sec = 0, .tv_nsec = 0, };
+
+    RCLCPP_INFO(this->get_logger(), "Inference Thread Starting");
+    RCLCPP_INFO(this->get_logger(), "Inference Loop Starting");
+
+    /*Inference Loop Start*/
+    while(1)
+    {
+        inf_cnt++;
+        while(1)
+        {
+            /* check if terminate() called or not. */
+            if (bExec == false)
+            {
+                goto ai_inf_end;
+            }
+            /*Checks if image frame from Capture Thread is ready.*/
+            if (inference_start.load())
+            {
+                break;
+            }
+            usleep(WAIT_TIME);
+        }
+
+        in_param.pre_in_addr    = capture_address;
+        /*Gets Pre-process starting time*/
+        ret = timespec_get(&pre_start_time, TIME_UTC);
+        if (0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to get Pre-process Start Time");
+            goto err;
+        }
+        ret = preruntime.Pre(&in_param, &output_ptr, &out_size);
+        if (0 < ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to run DRPAI_START: errno=%d", errno);
+            goto err;
+        }
+        /*Gets AI Pre-process End Time*/
+        ret = timespec_get(&pre_end_time, TIME_UTC);
+        if ( 0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to Get Pre-process End Time");
+            goto err;
+        }
+        /*Set Pre-processing output to be inference input. */
+        runtime.SetInput(0, (float*)output_ptr);
+        /*Pre-process Time Result*/
+        pre_time = (timedifference_msec(pre_start_time, pre_end_time) * TIME_COEF);
+
+        /*Gets inference starting time*/
+        ret = timespec_get(&inf_start_time, TIME_UTC);
+        if (0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to get Inference Start Time");
+            goto err;
+        }
+
+        runtime.Run(drpai_freq);
+
+        /*Gets AI Inference End Time*/
+        ret = timespec_get(&inf_end_time, TIME_UTC);
+        if ( 0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to Get Inference End Time");
+            goto err;
+        }
+        /*Inference Time Result*/
+        ai_time = (timedifference_msec(inf_start_time, inf_end_time) * TIME_COEF);
+
+        /*Gets Post-process starting time*/
+        ret = timespec_get(&post_start_time, TIME_UTC);
+        if (0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to get Post-process Start Time");
+            goto err;
+        }
+
+        /*Process to read the DRPAI output data.*/
+        ret = get_result();
+        if (0 != ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to get result from memory.");
+            goto err;
+        }
+        /*Preparation for Post-Processing*/
+        /*CPU Post-Processing For YOLOX*/
+        R_Post_Proc(drpai_output_buf);
+
+        /* R_Post_Proc time end*/
+        ret = timespec_get(&post_end_time, TIME_UTC);
+        if (0 == ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to Get R_Post_Proc End Time");
+            goto err;
+        }
+        post_time = (timedifference_msec(post_start_time, post_end_time)*TIME_COEF);
+
+        /*Display Processing Time On Log File*/
+        drpai_time = timedifference_msec(inf_start_time, inf_end_time) * TIME_COEF;
+        int idx = inf_cnt % SIZE_OF_ARRAY(array_drp_time);
+        ai_time = (uint32_t)((timedifference_msec(inf_start_time, inf_end_time) * TIME_COEF));
+        array_drp_time[idx] = ai_time;
+        drp_prev_time = inf_end_time;
+        uint32_t total_time = ai_time + pre_time + post_time;
+
+#ifdef DISP_AI_FRAME_RATE
+        int arraySum = std::accumulate(array_drp_time, array_drp_time + SIZE_OF_ARRAY(array_drp_time), 0);
+        double arrayAvg = 1.0 * arraySum / SIZE_OF_ARRAY(array_drp_time);
+        ai_fps = 1.0 / arrayAvg * 1000.0 + 0.5;
+        RCLCPP_INFO(this->get_logger(), "AI Frame Rate %d [fps]", (int32_t)ai_fps);
+#endif /* DISP_AI_FRAME_RATE */
+
+        inference_start.store(0);
+    }
+    /*End of Inference Loop*/
+
+/*Error Processing*/
+err:
+/*AI Thread Termination*/
+ai_inf_end:
+    /*To terminate the loop in Capture Thread.*/
+    RCLCPP_INFO(this->get_logger(), "AI Inference Thread Terminated");
+    pthread_exit(NULL);
+}
+
+
+/*****************************************
+* Function Name : camera_callback
+* Description   : Executed when the camera captures
+* Arguments     : msg = Image information messages sent from the V4L2 camera or RealSense2 camera node
+* Return value  : -
+******************************************/
+void DRPAINode::camera_callback(const sensor_msgs::msg::Image::ConstSharedPtr & msg)
+{
+    cv_bridge::CvImagePtr cam_image;
+    cam_image = cv_bridge::toCvCopy(msg, "rgb8");
+    uint8_t * p_img_buffer0;
+
+    /* cast check ok. no data losses pointer to pointer(void* to uint8_t*) */
+    p_img_buffer0 = (uint8_t *)p_drpai_buf->mem;
+
+    /* If the interface is down, keep the image */
+    if (!inference_start.load())
+    {
+        if (cam_image)
+        {
+            recv_img = cam_image->image.clone();
+            image_header = msg->header;
+
+            /* resize to learned model format */
+            if ((recv_img.size().width != CAM_IMAGE_WIDTH) || (recv_img.size().height != CAM_IMAGE_HEIGHT))
+            {
+                cv::resize(recv_img, recv_img, cv::Size(CAM_IMAGE_WIDTH, CAM_IMAGE_HEIGHT));
+            }
+            /* The weight of yolo is YUYV, so convert it to YUYV */
+            uint64_t idx;
+            for (idx = 0; idx < CAM_IMAGE_WIDTH * CAM_IMAGE_HEIGHT; idx++)
+            {
+                float64_t r = recv_img.data[3 * idx + 0];
+                float64_t g = recv_img.data[3 * idx + 1];
+                float64_t b = recv_img.data[3 * idx + 2];
+                float64_t y = 0.257 * r + 0.504 * g + 0.098 * b + 16.0;
+                float64_t u = -0.148 * r - 0.291 * g + 0.439 * b + 128.0;
+                float64_t v = 0.439 * r - 0.368 * g - 0.071 * b + 128.0;
+                float64_t uv;
+                if ((idx % 2) == 0)
+                {
+                    uv = u;
+                }
+                else
+                {
+                    uv = v;
+                }
+                if (y < 0)
+                {
+                    y = 0;
+                }
+                if (y > 255)
+                {
+                    y = 255;
+                }
+                if (uv < 0)
+                {
+                    uv = 0;
+                }
+                if (uv > 255)
+                {
+                    uv = 255;
+                }
+                /* cast check ok. Because y is trimmed to the range from 0 to 255 before casting. */
+                img.img_buffer[0][2 * idx + 0] = (uint8_t)y;
+                /* cast check ok. Because uv is trimmed to the range from 0 to 255 before casting. */
+                img.img_buffer[0][2 * idx + 1] = (uint8_t)uv;
+                /* cast check ok. Because y is trimmed to the range from 0 to 255 before casting. */
+                p_img_buffer0[2 * idx + 0] = (uint8_t)y;
+                /* cast check ok. Because uv is trimmed to the range from 0 to 255 before casting. */
+                p_img_buffer0[2 * idx + 1] = (uint8_t)uv;
+            }
+            /* launch the interface */
+            int ret = image_buffer_flush_dmabuf(p_image_buf->idx, p_image_buf->size);
+            if (0 != ret)
+            {
+                RCLCPP_INFO(this->get_logger(), "[ERROR] flush dmabuf error");
+                return;
+            }
+            ret = image_buffer_flush_dmabuf(p_drpai_buf->idx, p_drpai_buf->size);
+            if (0 != ret)
+            {
+                RCLCPP_INFO(this->get_logger(), "[ERROR] flush dmabuf error (drpai buffer) ");
+                return;
+            }
+            inference_start.store(1);
+        }
+    }
+    return;
+}
+
+/*****************************************
+* Function Name : get_drpai_start_addr
+* Description   : Function to get the start address of DRPAImem.
+* Arguments     : drpai_fd: DRP-AI file descriptor
+* Return value  : If non-zero, DRP-AI memory start address.
+*                 0 is failure.
+******************************************/
+uint64_t DRPAINode::get_drpai_start_addr(int drpai_fd)
+{
+    int ret = 0;
+    drpai_data_t drpai_data;
+
+    errno = 0;
+
+    /* Get DRP-AI Memory Area Address via DRP-AI Driver */
+    ret = ioctl(drpai_fd , DRPAI_GET_DRPAI_AREA, &drpai_data);
+    if (-1 == ret)
+    {
+        std::cerr << "[ERROR] Failed to get DRP-AI Memory Area : errno=" << errno << std::endl;
+        return 0;
+    }
+
+    return drpai_data.address;
+}
+
+/*****************************************
+* Function Name : set_drp_freq
+* Description   : Function to set the DRP frequency.
+* Arguments     : drpai_fd: DRP-AI file descriptor
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int DRPAINode::set_drp_freq(int drpai_fd)
+{
+    int ret = 0;
+    uint32_t data;
+
+    errno = 0;
+    data = drp_max_freq;
+    ret = ioctl(drpai_fd , DRPAI_SET_DRP_MAX_FREQ, &data);
+    if (-1 == ret)
+    {
+        std::cerr << "[ERROR] Failed to set DRP Max Frequency : errno=" << errno << std::endl;
+        return -1;
+    }
+
+    return 0;
+}
+
+/*****************************************
+* Function Name : init_drpai
+* Description   : Function to initialize DRP-AI.
+* Arguments     : drpai_fd: DRP-AI file descriptor
+* Return value  : If non-zero, DRP-AI memory start address.
+*                 0 is failure.
+******************************************/
+uint64_t DRPAINode::init_drpai(int drpai_fd)
+{
+    int ret = 0;
+    uint64_t drpai_addr = 0;
+
+    /*Get DRP-AI memory start address*/
+    drpai_addr = get_drpai_start_addr(drpai_fd);
+    if (drpai_addr == 0)
+    {
+        return 0;
+    }
+
+    /*Set DRP-AI frequency*/
+    ret = set_drp_freq(drpai_fd);
+    if (ret != 0)
+    {
+        return 0;
+    }
+
+    return drpai_addr;
+}
+
+/*****************************************
+* Function Name : main_entry
+* Description   : Function to initialize DRP-AI.
+* Arguments     : -
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int32_t DRPAINode::main_entry()
+{
+    using std::placeholders::_1;
+    drpai_path = "/darknet_drp_ros";
+    declare_parameter("config_path", drpai_path);
+    declare_parameter("drpai_freq", drpai_freq);
+    declare_parameter("drp_max_freq", drp_max_freq);
+
+    /* get ROS parameter */
+    get_parameter("confi_path", drpai_path);
+    get_parameter("drpai_freq", drpai_freq);
+    get_parameter("drp_max_freq", drp_max_freq);
+
+    /* create subscribe and publish */
+    image_subscriber = image_transport::create_subscription(this, 
+                            std::string("/camera/image_raw"),
+                            std::bind(&DRPAINode::camera_callback, this, _1),
+                            "raw");
+    object_publisher = this->create_publisher<darknet_ros_msgs::msg::ObjectCount>(
+                            std::string("found_object"), 1);
+    bounding_boxes_publisher = this->create_publisher<darknet_ros_msgs::msg::BoundingBoxes>(
+                                std::string("bounding_boxes"), 1);
+    detection_image_publisher = this->create_publisher<sensor_msgs::msg::Image>(
+                                std::string("detection_image"), 1);
+
+    int8_t main_proc = 0;
+    int8_t ret = 0;
+    int8_t ret_main = 0;
+    InOutDataType input_data_type;
+    bool runtime_status = false;
+    uint8_t * p_img_buffer0;
+
+    RCLCPP_INFO(this->get_logger(), "************************************************");
+    RCLCPP_INFO(this->get_logger(), "  RZ/V2H DRP-AI Sample Application");
+    RCLCPP_INFO(this->get_logger(), "  Model : Lightnet YOLOX | %s", drpai_path.c_str());
+    RCLCPP_INFO(this->get_logger(), "  Input : USB Camera");
+    RCLCPP_INFO(this->get_logger(), "************************************************");
+
+    /* create image buffer */
+    /* cast check ok. There is no problem because it is malloc with the size of image_dma_buffer. */
+    p_image_buf = (image_dma_buffer*)malloc(sizeof(image_dma_buffer));
+    ret = image_buffer_alloc_dmabuf(p_image_buf, IMAGEBUF);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to Allocate DMA buffer for the p_image_buf");
+        return -1;
+    }
+    uint64_t drpaimem_addr_start = 0;
+    
+    errno = 0;
+    g_drpai_fd0 = open("/dev/drpai0", O_RDWR);
+    if (0 > g_drpai_fd0)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to open DRP-AI Driver : errno=%d", errno);
+        goto end_threads;
+    }
+    
+    /*Initialzie DRP-AI (Get DRP-AI memory address and set DRP-AI frequency)*/
+    drpaimem_addr_start = init_drpai(g_drpai_fd0);
+    if (drpaimem_addr_start == 0)
+    {
+        goto end_threads;
+    }
+
+    /*Load pre_dir object to DRP-AI */
+    ret = preruntime.Load(drpai_path + "/preprocess");
+    if (0 < ret)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to run Pre-processing Runtime Load().");
+        goto end_threads;
+    }
+
+    runtime_status = runtime.LoadModel(drpai_path, drpaimem_addr_start);
+
+    if(!runtime_status)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to load model.");
+        goto end_threads;
+    }
+
+    /*Get input data */
+    input_data_type = runtime.GetInputDataType(0);
+    if (InOutDataType::FLOAT32 == input_data_type)
+    {
+        /*Do nothing*/
+    }
+    else if (InOutDataType::FLOAT16 == input_data_type)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Input data type : FP16.");
+        /*If your model input data type is FP16, use std::vector<uint16_t> for reading input data. */
+        goto end_threads;
+    }
+    else
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Input data type : neither FP32 nor FP16.");
+        goto end_threads;
+    }
+
+    /* Create drpai_buffer */
+    /* cast check ok. There is no problem because it is malloc with the size of image_dma_buffer. */
+    p_drpai_buf = (image_dma_buffer*)malloc(sizeof(image_dma_buffer));
+    ret = image_buffer_alloc_dmabuf(p_drpai_buf, DRPAIBUF);
+    if (-1 == ret)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to Allocate DMA buffer for the drpai_buf");
+        ret_main = ret;
+        goto end_threads;
+    }
+
+    /* cast check ok. no data losses pointer to pointer(void* to uint8_t*) */
+    p_img_buffer0 = (uint8_t *)p_drpai_buf->mem;
+#if (1) == DRPAI_INPUT_PADDING
+    /** Fill buffer with the brightness 114.
+     *  When the format of input image is smaller than learned model data,
+     *  object detection algorithm should ignore the rest area.
+     */
+    for (uint32_t i = 0; i < CAM_IMAGE_WIDTH * CAM_IMAGE_WIDTH * CAM_IMAGE_CHANNEL_YUY2; i += 4)
+    {
+        /* Y =  0.299R + 0.587G + 0.114B */
+        p_img_buffer0[i]     = 114;
+        p_img_buffer0[i + 2] = 114;
+        /* U = -0.169R - 0.331G + 0.500B + 128 */
+        p_img_buffer0[i + 1] = 128;
+        /* V =  0.500R - 0.419G - 0.081B + 128 */
+        p_img_buffer0[i + 3] = 128;
+    }
+#endif  /* (1) == DRPAI_INPUT_PADDING */
+    capture_address = p_drpai_buf->phy_addr;
+
+    /*Initialize Image object.*/
+    ret = img.init(CAM_IMAGE_WIDTH, CAM_IMAGE_HEIGHT, CAM_IMAGE_CHANNEL_YUY2,
+        IMAGE_OUTPUT_WIDTH, IMAGE_OUTPUT_HEIGHT, IMAGE_CHANNEL_BGRA, p_image_buf->mem);
+    if (0 != ret)
+    {
+        RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to initialize Image object.");
+        ret_main = ret;
+        goto end_threads;
+    }
+
+    /*Create Inference Thread*/
+    ai_inf_thread = std::thread(&DRPAINode::R_Inf_Thread, this);
+
+end_threads:
+    return ret_main;
+}
+
+/*****************************************
+* Function Name : terminate
+* Description   : terminate the DRP-AI inference thread
+* Arguments     : none
+* Return value  : -
+******************************************/
+void DRPAINode::terminate()
+{
+    int ret;
+    bExec = false;
+    ai_inf_thread.join();
+
+    /* free DRP-AI Input image buffer */
+    image_buffer_free_dmabuf(p_drpai_buf);
+    free(p_drpai_buf);
+    p_drpai_buf = NULL;
+
+    /* free image buffer */
+    image_buffer_free_dmabuf(p_image_buf);
+    free(p_image_buf);
+    p_image_buf = NULL;
+
+    /* Close DRP-AI Driver. */
+    if (0 < g_drpai_fd0)
+    {
+        errno = 0;
+        ret = close(g_drpai_fd0);
+        if (0 != ret)
+        {
+            RCLCPP_INFO(this->get_logger(), "[ERROR] Failed to close DRP-AI Driver: errno=%d", errno);
+        }
+    }
+    RCLCPP_INFO(this->get_logger(), "Application End");
+    return;
+}
+
+/*****************************************
+* Function Name : image_buffer_alloc_dmabuf
+* Description   : Allocate a DMA buffer for the image
+* Arguments     : buffer = pointer to the image_dma_buffer struct
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int8_t DRPAINode::image_buffer_alloc_dmabuf(struct image_dma_buffer *buffer, int buf_size)
+{
+    MMNGR_ID id;
+    uint32_t phard_addr;
+    void *puser_virt_addr;
+    int m_dma_fd;
+
+    buffer->size = buf_size;
+    mmngr_alloc_in_user_ext(&id, buffer->size, &phard_addr, &puser_virt_addr, MMNGR_VA_SUPPORT_CACHED, NULL);
+    memset((void*)puser_virt_addr, 0, buffer->size);
+    buffer->idx = id;
+    buffer->mem = (void *)puser_virt_addr;
+    buffer->phy_addr = phard_addr;
+    if (!buffer->mem)
+    {
+        return -1;
+    }
+    mmngr_export_start_in_user_ext(&id, buffer->size, phard_addr, &m_dma_fd, NULL);
+    buffer->dbuf_fd = m_dma_fd;
+    return 0;
+}
+
+/*****************************************
+* Function Name : image_buffer_free_dmabuf
+* Description   : free a DMA buffer for the image
+* Arguments     : buffer = pointer to the image_dma_buffer struct
+* Return value  : -
+******************************************/
+void DRPAINode::image_buffer_free_dmabuf(struct image_dma_buffer *buffer)
+{
+    mmngr_free_in_user_ext(buffer->idx);
+    return;
+}
+
+/*****************************************
+* Function Name : image_buffer_flush_dmabuf
+* Description   : flush a DMA buffer for the image
+* Arguments     : buffer = pointer to the image_dma_buffer struct
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int DRPAINode::image_buffer_flush_dmabuf(uint32_t idx, uint32_t size)
+{
+    int mm_ret = 0;
+    
+    /* Flush capture image area cache */
+    mm_ret = mmngr_flush(idx, 0, size);
+    
+    return mm_ret;
+}
+
+/*****************************************
+* Function Name : DRPAINode
+* Description   : constructor
+* Arguments     : -
+* Return value  : -
+******************************************/
+DRPAINode::DRPAINode() : Node("darknet_drp_ros")
+{
+}
+
+/*****************************************
+* Function Name : ~DRPAINode
+* Description   : destructor
+* Arguments     : -
+* Return value  : -
+******************************************/
+DRPAINode::~DRPAINode()
+{
+}
+} /* namespace drpai */
+
+/*****************************************
+* Function Name : main
+* Description   : Run drpai node and ROS Client Library for C++ package.
+* Arguments     : argc = argument count
+*               : argv = argument vector
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int main(int argc, char** argv)
+{
+    rclcpp::init(argc, argv);
+
+    std::shared_ptr<drpai::DRPAINode> drpai_node = std::make_shared<drpai::DRPAINode>();
+
+    /* run drpai node */
+    drpai_node->main_entry();
+
+    /* run ROS Client Library for C++ package */
+    rclcpp::Rate loop_rate(60);
+    while (rclcpp::ok())
+    {
+        rclcpp::spin_some(drpai_node);
+        loop_rate.sleep();
+    }
+
+    drpai_node->terminate();
+
+    rclcpp::shutdown();
+
+    return 0;
+}
diff --git a/darknet_drp_ros/src/main.h b/darknet_drp_ros/src/main.h
new file mode 100644
index 0000000..e0d66e5
--- /dev/null
+++ b/darknet_drp_ros/src/main.h
@@ -0,0 +1,127 @@
+/**********************************************************************************************************************
+* Copyright (C) 2024 Renesas Electronics Corporation. All rights reserved.
+**********************************************************************************************************************/
+/**********************************************************************************************************************
+* File Name    : main.h
+* Version      : 0.90
+* Description  : RZ/V2H DRP-AI Sample Application for Megvii-Base Detection YOLOX with MIPI/USB Camera
+**********************************************************************************************************************/
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/* This block of code is only accessible from C code. */
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <mmngr_user_public.h>
+#include <mmngr_buf_user_public.h>
+#ifdef __cplusplus
+}
+#endif
+
+/* ROS */
+#include "rclcpp/rclcpp.hpp"
+#include "rclcpp_action/rclcpp_action.hpp"
+#include "std_msgs/msg/header.hpp"
+#include "sensor_msgs/msg/image.hpp"
+#include "geometry_msgs/msg/point.hpp"
+#include "image_transport/image_transport.hpp"
+
+#include "darknet_ros_msgs/msg/bounding_boxes.hpp"
+#include "darknet_ros_msgs/msg/bounding_box.hpp"
+#include "darknet_ros_msgs/msg/object_count.hpp"
+#include "darknet_ros_msgs/action/check_for_objects.hpp"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+#ifndef MAIN_H
+#define MAIN_H
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+typedef double float64_t;
+
+namespace drpai
+{
+    class DRPAINode : public rclcpp::Node
+    {
+    public:
+        typedef struct image_dma_buffer
+        {
+            /* The index of the buffer. */
+            uint32_t idx;
+            /* The file descriptor for the DMA buffer. */
+            uint32_t dbuf_fd;
+            /* The size of the buffer in bytes. */
+            uint32_t size;
+            /* The physical address of DMA buffer. */
+            uint32_t phy_addr;
+            /* The pointer to the memory for the buffer. */
+            void *mem;
+        } image_dma_buffer_t;
+        explicit DRPAINode();
+        ~DRPAINode();
+        int32_t start_proc();
+        int32_t main_entry();
+        void terminate();
+        void *R_Inf_Thread();
+
+        void R_Post_Proc(float* floatarr);
+        int8_t R_Main_Process(void);
+        double timedifference_msec(struct timespec t0, struct timespec t1);
+        void draw_bounding_box(void);
+
+        uint64_t get_drpai_start_addr(int drpai_fd);
+        int set_drp_freq(int drpai_fd);
+        uint64_t init_drpai(int drpai_fd);
+
+        void camera_callback(const sensor_msgs::msg::Image::ConstSharedPtr & msg);
+        std_msgs::msg::Header image_header;
+
+        /* ROS subscriber and publisher */
+        /* subscribe: for camera image */
+        image_transport::Subscriber image_subscriber;
+        /* publish: number of found objects */
+        rclcpp::Publisher<darknet_ros_msgs::msg::ObjectCount>::SharedPtr object_publisher;
+        /* publish: information of bounding box rectangle about detected object */
+        rclcpp::Publisher<darknet_ros_msgs::msg::BoundingBoxes>::SharedPtr bounding_boxes_publisher;
+        /* publish: detected image */
+        rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr detection_image_publisher;
+        /* camera raw image buffer */
+        struct image_dma_buffer *p_image_buf;
+        /* detected image drawing buffer */
+        struct image_dma_buffer *p_drpai_buf;
+
+        int8_t image_buffer_alloc_dmabuf(struct image_dma_buffer *buffer, int buf_size);
+        void image_buffer_free_dmabuf(struct image_dma_buffer *buffer);
+        int image_buffer_flush_dmabuf(uint32_t idx, uint32_t size);
+
+        int32_t ceil3(int32_t num, int32_t base);
+        int8_t get_result();
+        double sigmoid(double x);
+        void softmax(float val[NUM_CLASS]);
+        int32_t index(uint8_t n, int32_t offs, int32_t channel);
+        int32_t offset(uint8_t n, int32_t b, int32_t y, int32_t x);
+
+        /* working buffer for resizing camera image */
+        cv::Mat recv_img;
+        /* parameter for DRP-AI freq. */
+        int drpai_freq = DRPAI_FREQ;
+        /* parameter for DRP-AI max freq. */
+        int32_t drp_max_freq = DRP_MAX_FREQ;
+        /* root path to learned model */
+        std::string drpai_path;
+        /* DRP-AI inference thread instance */
+        std::thread ai_inf_thread;
+        /* flag for application termination */
+        bool bExec = true;
+    };
+
+} /* namespace drpai */
+
+#endif /* MAIN_H */
diff --git a/darknet_ros/test/ObjectDetection.cpp b/darknet_drp_ros/test/ObjectDetection.cpp
similarity index 100%
rename from darknet_ros/test/ObjectDetection.cpp
rename to darknet_drp_ros/test/ObjectDetection.cpp
diff --git a/darknet_ros/test/object_detection.test b/darknet_drp_ros/test/object_detection.test
similarity index 100%
rename from darknet_ros/test/object_detection.test
rename to darknet_drp_ros/test/object_detection.test
diff --git a/darknet_ros/test/test_main.cpp b/darknet_drp_ros/test/test_main.cpp
similarity index 100%
rename from darknet_ros/test/test_main.cpp
rename to darknet_drp_ros/test/test_main.cpp
diff --git a/darknet_ros/test/yolov2.yaml b/darknet_drp_ros/test/yolov2.yaml
similarity index 100%
rename from darknet_ros/test/yolov2.yaml
rename to darknet_drp_ros/test/yolov2.yaml
diff --git a/darknet_ros/yolo_network_config/cfg/yolov2-tiny-voc.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov2-tiny-voc.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov2-tiny-voc.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov2-tiny-voc.cfg
diff --git a/darknet_ros/yolo_network_config/cfg/yolov2-tiny.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov2-tiny.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov2-tiny.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov2-tiny.cfg
diff --git a/darknet_ros/yolo_network_config/cfg/yolov2-voc.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov2-voc.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov2-voc.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov2-voc.cfg
diff --git a/darknet_ros/yolo_network_config/cfg/yolov2.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov2.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov2.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov2.cfg
diff --git a/darknet_ros/yolo_network_config/cfg/yolov3-voc.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov3-voc.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov3-voc.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov3-voc.cfg
diff --git a/darknet_ros/yolo_network_config/cfg/yolov3.cfg b/darknet_drp_ros/yolo_network_config/cfg/yolov3.cfg
similarity index 100%
rename from darknet_ros/yolo_network_config/cfg/yolov3.cfg
rename to darknet_drp_ros/yolo_network_config/cfg/yolov3.cfg
diff --git a/darknet_ros/yolo_network_config/weights/.gitignore b/darknet_drp_ros/yolo_network_config/weights/.gitignore
similarity index 100%
rename from darknet_ros/yolo_network_config/weights/.gitignore
rename to darknet_drp_ros/yolo_network_config/weights/.gitignore
diff --git a/darknet_ros/yolo_network_config/weights/how_to_download_weights.txt b/darknet_drp_ros/yolo_network_config/weights/how_to_download_weights.txt
similarity index 100%
rename from darknet_ros/yolo_network_config/weights/how_to_download_weights.txt
rename to darknet_drp_ros/yolo_network_config/weights/how_to_download_weights.txt
diff --git a/darknet_ros/CMakeLists.txt b/darknet_ros/CMakeLists.txt
deleted file mode 100644
index 56dbad5..0000000
--- a/darknet_ros/CMakeLists.txt
+++ /dev/null
@@ -1,260 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(darknet_ros)
-
-set(CMAKE_CXX_STANDARD 17)
-
-# Define path of darknet folder here.
-find_path(DARKNET_PATH
-  NAMES "README.md"
-  HINTS "${CMAKE_CURRENT_SOURCE_DIR}/../darknet/")
-message(STATUS "Darknet path dir = ${DARKNET_PATH}")
-add_definitions(-DDARKNET_FILE_PATH="${DARKNET_PATH}")
-
-# Find CUDA
-find_package(CUDA QUIET)
-if (CUDA_FOUND)
-  find_package(CUDA REQUIRED)
-  message(STATUS "CUDA Version: ${CUDA_VERSION_STRINGS}")
-  message(STATUS "CUDA Libararies: ${CUDA_LIBRARIES}")
-  set(
-    CUDA_NVCC_FLAGS
-    ${CUDA_NVCC_FLAGS};
-    -O3
-    -gencode arch=compute_30,code=sm_30
-    -gencode arch=compute_35,code=sm_35
-    -gencode arch=compute_50,code=[sm_50,compute_50]
-    -gencode arch=compute_52,code=[sm_52,compute_52]
-    -gencode arch=compute_61,code=sm_61
-    -gencode arch=compute_62,code=sm_62
-  )
-  add_definitions(-DGPU)
-else()
-  list(APPEND LIBRARIES "m")
-endif()
-
-# Find X11
-message ( STATUS "Searching for X11..." )
-find_package ( X11 REQUIRED )
-if ( X11_FOUND )
-  include_directories ( ${X11_INCLUDE_DIR} )
-  link_libraries ( ${X11_LIBRARIES} )
-  message ( STATUS " X11_INCLUDE_DIR: " ${X11_INCLUDE_DIR} )
-  message ( STATUS " X11_LIBRARIES: " ${X11_LIBRARIES} )
-endif ( X11_FOUND )
-
-# Find rquired packeges
-find_package(OpenCV REQUIRED)
-include_directories(${OpenCV_INCLUDE_DIRS})
-
-find_package(ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(rclpy REQUIRED)
-find_package(rclcpp_action REQUIRED)
-find_package(std_msgs REQUIRED)
-find_package(image_transport REQUIRED)
-find_package(cv_bridge REQUIRED)
-find_package(sensor_msgs REQUIRED)
-find_package(darknet_ros_msgs REQUIRED)
-find_package(ament_index_cpp REQUIRED)
-
-set(dependencies
-    rclcpp
-    rclpy
-    rclcpp_action
-    std_msgs
-    image_transport
-    cv_bridge
-    sensor_msgs
-    darknet_ros_msgs
-    ament_index_cpp
-)
-
-# Enable OPENCV in darknet
-# add_definitions(-DOPENCV)
-add_definitions(-O4 -g)
-
-include_directories(
-  ${DARKNET_PATH}/src
-  ${DARKNET_PATH}/include
-  include
-  ${catkin_INCLUDE_DIRS}
-)
-
-set(PROJECT_LIB_FILES
-    src/YoloObjectDetector.cpp                    src/image_interface.c
-)
-
-set(DARKNET_CORE_FILES
-    ${DARKNET_PATH}/src/activation_layer.c        ${DARKNET_PATH}/src/im2col.c
-    ${DARKNET_PATH}/src/activations.c             ${DARKNET_PATH}/src/image.c
-    ${DARKNET_PATH}/src/avgpool_layer.c           ${DARKNET_PATH}/src/layer.c
-    ${DARKNET_PATH}/src/batchnorm_layer.c         ${DARKNET_PATH}/src/list.c
-    ${DARKNET_PATH}/src/blas.c                    ${DARKNET_PATH}/src/local_layer.c
-    ${DARKNET_PATH}/src/box.c                     ${DARKNET_PATH}/src/lstm_layer.c
-    ${DARKNET_PATH}/src/col2im.c                  ${DARKNET_PATH}/src/matrix.c
-    ${DARKNET_PATH}/src/connected_layer.c         ${DARKNET_PATH}/src/maxpool_layer.c
-    ${DARKNET_PATH}/src/convolutional_layer.c     ${DARKNET_PATH}/src/network.c
-    ${DARKNET_PATH}/src/cost_layer.c              ${DARKNET_PATH}/src/normalization_layer.c
-    ${DARKNET_PATH}/src/crnn_layer.c              ${DARKNET_PATH}/src/option_list.c
-    ${DARKNET_PATH}/src/crop_layer.c              ${DARKNET_PATH}/src/parser.c
-    ${DARKNET_PATH}/src/cuda.c                    ${DARKNET_PATH}/src/region_layer.c
-    ${DARKNET_PATH}/src/data.c                    ${DARKNET_PATH}/src/reorg_layer.c
-    ${DARKNET_PATH}/src/deconvolutional_layer.c   ${DARKNET_PATH}/src/rnn_layer.c
-    ${DARKNET_PATH}/src/demo.c                    ${DARKNET_PATH}/src/route_layer.c
-    ${DARKNET_PATH}/src/detection_layer.c         ${DARKNET_PATH}/src/shortcut_layer.c
-    ${DARKNET_PATH}/src/dropout_layer.c           ${DARKNET_PATH}/src/softmax_layer.c
-    ${DARKNET_PATH}/src/gemm.c                    ${DARKNET_PATH}/src/tree.c
-    ${DARKNET_PATH}/src/gru_layer.c               ${DARKNET_PATH}/src/utils.c
-    ${DARKNET_PATH}/src/upsample_layer.c          ${DARKNET_PATH}/src/logistic_layer.c
-    ${DARKNET_PATH}/src/l2norm_layer.c            ${DARKNET_PATH}/src/yolo_layer.c
-
-    ${DARKNET_PATH}/examples/art.c                ${DARKNET_PATH}/examples/lsd.c
-    ${DARKNET_PATH}/examples/attention.c          ${DARKNET_PATH}/examples/nightmare.c
-    ${DARKNET_PATH}/examples/captcha.c            ${DARKNET_PATH}/examples/regressor.c
-    ${DARKNET_PATH}/examples/cifar.c              ${DARKNET_PATH}/examples/rnn.c
-    ${DARKNET_PATH}/examples/classifier.c         ${DARKNET_PATH}/examples/segmenter.c
-    ${DARKNET_PATH}/examples/coco.c               ${DARKNET_PATH}/examples/super.c
-    ${DARKNET_PATH}/examples/darknet.c            ${DARKNET_PATH}/examples/tag.c
-    ${DARKNET_PATH}/examples/detector.c           ${DARKNET_PATH}/examples/yolo.c
-    ${DARKNET_PATH}/examples/go.c
-)
-
-set(DARKNET_CUDA_FILES
-    ${DARKNET_PATH}/src/activation_kernels.cu     ${DARKNET_PATH}/src/crop_layer_kernels.cu
-    ${DARKNET_PATH}/src/avgpool_layer_kernels.cu  ${DARKNET_PATH}/src/deconvolutional_kernels.cu
-    ${DARKNET_PATH}/src/blas_kernels.cu           ${DARKNET_PATH}/src/dropout_layer_kernels.cu
-    ${DARKNET_PATH}/src/col2im_kernels.cu         ${DARKNET_PATH}/src/im2col_kernels.cu
-    ${DARKNET_PATH}/src/convolutional_kernels.cu  ${DARKNET_PATH}/src/maxpool_layer_kernels.cu
-)
-
-set_source_files_properties(${PROJECT_LIB_FILES} PROPERTIES LANGUAGE CXX)
-
-if (CUDA_FOUND)
-
-  link_directories(
-    ${CUDA_TOOLKIT_ROOT_DIR}/lib64
-  )
-
-  cuda_add_library(${PROJECT_NAME}_lib
-    ${PROJECT_LIB_FILES} ${DARKNET_CORE_FILES}
-    ${DARKNET_CUDA_FILES}
-  )
-  
-  ament_target_dependencies(${PROJECT_NAME}_lib ${dependencies})
-
-  target_link_libraries(${PROJECT_NAME}_lib
-    cuda
-    cudart
-    cublas
-    curand
-  )
-
-  cuda_add_executable(${PROJECT_NAME}
-    src/yolo_object_detector_node.cpp
-  )
-  
-  ament_target_dependencies(${PROJECT_NAME} ${dependencies})
-
-else()
-
-  add_library(${PROJECT_NAME}_core_lib
-    ${DARKNET_CORE_FILES}
-  )
-
-  add_library(${PROJECT_NAME}_lib
-    ${PROJECT_LIB_FILES}
-  )
-  ament_target_dependencies(${PROJECT_NAME}_lib ${dependencies})
-  target_compile_definitions(${PROJECT_NAME}_lib PRIVATE -DOPENCV)
-
-  add_executable(${PROJECT_NAME}
-    src/yolo_object_detector_node.cpp
-  )
-  ament_target_dependencies(${PROJECT_NAME} ${dependencies})
-
-endif()
-
-target_link_libraries(${PROJECT_NAME}_lib
-  m
-  pthread
-  stdc++
-  ${OpenCV_LIBRARIES}
-  ${catkin_LIBRARIES}
-  ${OpenCV_LIBS}
-)
-target_compile_definitions(${PROJECT_NAME}_lib PRIVATE -DOPENCV)
-
-target_link_libraries(${PROJECT_NAME}
-  ${PROJECT_NAME}_lib
-  ${PROJECT_NAME}_core_lib
-)
-target_compile_definitions(${PROJECT_NAME} PRIVATE -DOPENCV)
-
-install(TARGETS ${PROJECT_NAME}_lib ${PROJECT_NAME}
-  ARCHIVE DESTINATION lib
-  LIBRARY DESTINATION lib
-  RUNTIME DESTINATION lib/${PROJECT_NAME}
-)
-
-
-install(
-  DIRECTORY include/
-  DESTINATION include/
-  FILES_MATCHING PATTERN "*.h"
-)
-
-# Download yolov2-tiny.weights
-set(PATH "${CMAKE_CURRENT_SOURCE_DIR}/yolo_network_config/weights")
-set(FILE "${PATH}/yolov2-tiny.weights")
-message(STATUS "Checking and downloading yolov2-tiny.weights if needed ...")
-if (NOT EXISTS "${FILE}")
-  message(STATUS "... file does not exist. Downloading now ...")
-  execute_process(COMMAND wget http://pjreddie.com/media/files/yolov2-tiny.weights -P ${PATH})
-endif()
-
-# Download yolov3.weights
-set(FILE "${PATH}/yolov3.weights")
-message(STATUS "Checking and downloading yolov3.weights if needed ...")
-if (NOT EXISTS "${FILE}")
-  message(STATUS "... file does not exist. Downloading now ...")
-  execute_process(COMMAND wget http://pjreddie.com/media/files/yolov3.weights -P ${PATH})
-endif()
-
-install(DIRECTORY yolo_network_config/cfg yolo_network_config/weights DESTINATION share/${PROJECT_NAME}/yolo_network_config/)
-install(DIRECTORY launch config DESTINATION share/${PROJECT_NAME}/)
-
-#############
-## Testing ##
-#############
-
-if(BUILD_TESTING)
-  # Download yolov2.weights
-  set(PATH "${CMAKE_CURRENT_SOURCE_DIR}/yolo_network_config/weights")
-  set(FILE "${PATH}/yolov2.weights")
-  message(STATUS "Checking and downloading yolov2.weights if needed ...")
-  if (NOT EXISTS "${FILE}")
-    message(STATUS "... file does not exist. Downloading now ...")
-    execute_process(COMMAND wget http://pjreddie.com/media/files/yolov2.weights -P ${PATH})
-  endif()
-
-  find_package(ament_lint_auto REQUIRED)
-  ament_lint_auto_find_test_dependencies()
-
-  find_package(ament_cmake_gtest REQUIRED)
-  
-  #ament_add_gtest(${PROJECT_NAME}_object_detection-test
-  #  test/object_detection.test
-  #  test/test_main.cpp
-  #  test/ObjectDetection.cpp
-  #)
-  #target_link_libraries(${PROJECT_NAME}_object_detection-test
-  #  ${PROJECT_NAME}_lib
-  #)
-endif()
-
-
-ament_export_include_directories(include)
-ament_export_libraries(${PROJECT_NAME}_lib)
-ament_export_dependencies(${dependencies})
-
-ament_package()
\ No newline at end of file
diff --git a/darknet_ros/include/darknet_ros/YoloObjectDetector.hpp b/darknet_ros/include/darknet_ros/YoloObjectDetector.hpp
deleted file mode 100644
index 1314455..0000000
--- a/darknet_ros/include/darknet_ros/YoloObjectDetector.hpp
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * YoloObjectDetector.h
- *
- *  Created on: Dec 19, 2016
- *      Author: Marko Bjelonic
- *   Institute: ETH Zurich, Robotic Systems Lab
- */
-
-#pragma once
-
-// c++
-#include <math.h>
-#include <string>
-#include <vector>
-#include <iostream>
-#include <pthread.h>
-#include <thread>
-#include <chrono>
-#include <shared_mutex>
-
-// ROS
-#include "rclcpp/rclcpp.hpp"
-#include "rclcpp_action/rclcpp_action.hpp"
-#include "std_msgs/msg/header.hpp"
-#include "sensor_msgs/msg/image.hpp"
-#include "geometry_msgs/msg/point.hpp"
-#include "image_transport/image_transport.h"
-
-// OpenCv
-#include <opencv2/imgproc/imgproc.hpp>
-#include <opencv2/highgui/highgui.hpp>
-#include <opencv2/objdetect/objdetect.hpp>
-#include <cv_bridge/cv_bridge.h>
-
-// darknet_ros_msgs
-#include "darknet_ros_msgs/msg/bounding_boxes.hpp"
-#include "darknet_ros_msgs/msg/bounding_box.hpp"
-#include "darknet_ros_msgs/msg/object_count.hpp"
-#include "darknet_ros_msgs/action/check_for_objects.hpp"
-
-// Darknet.
-#ifdef GPU
-#include "cuda_runtime.h"
-#include "curand.h"
-#include "cublas_v2.h"
-#endif
-
-extern "C" {
-#include "network.h"
-#include "detection_layer.h"
-#include "region_layer.h"
-#include "cost_layer.h"
-#include "utils.h"
-#include "parser.h"
-#include "box.h"
-#include "darknet_ros/image_interface.h"
-#include <sys/time.h>
-}
-
-extern "C" void ipl_into_image(IplImage* src, image im);
-extern "C" image ipl_to_image(IplImage* src);
-extern "C" void show_image_cv(image p, const char *name, IplImage *disp);
-
-namespace darknet_ros {
-
-//! Bounding box of the detected object.
-typedef struct
-{
-  float x, y, w, h, prob;
-  int num, Class;
-} RosBox_;
-
-typedef struct
-{
-  IplImage* image;
-  std_msgs::msg::Header header;
-} IplImageWithHeader_;
-
-class YoloObjectDetector : public rclcpp::Node
-{
- public:
-  /*!
-   * Constructor.
-   */
-  explicit YoloObjectDetector();
-
-  /*!
-   * Destructor.
-   */
-  ~YoloObjectDetector();
-
-  /*!
-   * Initialize the ROS connections.
-   */
-  void init();
-
- private:
-  /*!
-   * Reads and verifies the ROS parameters.
-   * @return true if successful.
-   */
-  bool readParameters();
-
-  /*!
-   * Callback of camera.
-   * @param[in] msg image pointer.
-   */
-  void cameraCallback(const sensor_msgs::msg::Image::ConstSharedPtr & msg);
-
-
-  //! Typedefs.
-  using CheckForObjectsAction = darknet_ros_msgs::action::CheckForObjects;
-  using GoalHandleCheckForObjectsAction = rclcpp_action::ServerGoalHandle<CheckForObjectsAction>;
-
-  /*!
-   * Check for objects action goal callback.
-   */
-  rclcpp_action::GoalResponse checkForObjectsActionGoalCB(
-    const rclcpp_action::GoalUUID & uuid,
-    std::shared_ptr<const CheckForObjectsAction::Goal> goal);
-
-  /*!
-   * Check for objects action preempt callback.
-   */
-  rclcpp_action::CancelResponse checkForObjectsActionPreemptCB(
-    const std::shared_ptr<GoalHandleCheckForObjectsAction> goal_handle);
-
-  /*!ÂºÂº
-   * Check for objects action accept callback.
-   */
-  void checkForObjectsActionAcceptedCB(
-    const std::shared_ptr<GoalHandleCheckForObjectsAction> goal_handle);
-
-  /*!
-   * Check if a preempt for the check for objects action has been requested.
-   * @return false if preempt has been requested or inactive.
-   */
-  bool isCheckingForObjects() const;
-
-  /*!
-   * Publishes the detection image.
-   * @return true if successful.
-   */
-  bool publishDetectionImage(const cv::Mat& detectionImage);
-
-  //! Class labels.
-  int numClasses_;
-  std::vector<std::string> classLabels_;
-
-  //! Check for objects action server.
-  rclcpp_action::Server<CheckForObjectsAction>::SharedPtr checkForObjectsActionServer_;
-  bool action_active_;
-  bool preempt_requested_;
-  std::shared_ptr<GoalHandleCheckForObjectsAction> goal_handle_;
-
-  //! Advertise and subscribe to image topics.
-  std::shared_ptr<image_transport::ImageTransport> it_;
-
-  //! ROS subscriber and publisher.
-  image_transport::Subscriber imageSubscriber_;
-  rclcpp::Publisher<darknet_ros_msgs::msg::ObjectCount>::SharedPtr objectPublisher_;
-  rclcpp::Publisher<darknet_ros_msgs::msg::BoundingBoxes>::SharedPtr boundingBoxesPublisher_;
-
-  //! Detected objects.
-  std::vector<std::vector<RosBox_> > rosBoxes_;
-  std::vector<int> rosBoxCounter_;
-  darknet_ros_msgs::msg::BoundingBoxes boundingBoxesResults_;
-
-  //! Camera related parameters.
-  int frameWidth_;
-  int frameHeight_;
-
-  //! Publisher of the bounding box image.
-  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr detectionImagePublisher_;
-
-  // Yolo running on thread.
-  std::thread yoloThread_;
-
-  // Darknet.
-  char **demoNames_;
-  image **demoAlphabet_;
-  int demoClasses_;
-
-  network *net_;
-  std_msgs::msg::Header headerBuff_[3];
-  image buff_[3];
-  image buffLetter_[3];
-  int buffId_[3];
-  int buffIndex_ = 0;
-  IplImage * ipl_;
-  float fps_ = 0;
-  float demoThresh_ = 0;
-  float demoHier_ = .5;
-  int running_ = 0;
-
-  int demoDelay_ = 0;
-  int demoFrame_ = 3;
-  float **predictions_;
-  int demoIndex_ = 0;
-  int demoDone_ = 0;
-  float *lastAvg2_;
-  float *lastAvg_;
-  float *avg_;
-  int demoTotal_ = 0;
-  double demoTime_;
-
-  RosBox_ *roiBoxes_;
-  bool viewImage_;
-  bool enableConsoleOutput_;
-  int waitKeyDelay_;
-  int fullScreen_;
-  char *demoPrefix_;
-
-  std_msgs::msg::Header imageHeader_;
-  cv::Mat camImageCopy_;
-  std::shared_mutex mutexImageCallback_;
-
-  bool imageStatus_ = false;
-  std::shared_mutex mutexImageStatus_;
-
-  bool isNodeRunning_ = true;
-  std::shared_mutex mutexNodeStatus_;
-
-  int actionId_;
-  std::shared_mutex mutexActionStatus_;
-
-  // double getWallTime();
-
-  int sizeNetwork(network *net);
-
-  void rememberNetwork(network *net);
-
-  detection *avgPredictions(network *net, int *nboxes);
-
-  void *detectInThread();
-
-  void *fetchInThread();
-
-  void *displayInThread(void *ptr);
-
-  void *displayLoop(void *ptr);
-
-  void *detectLoop(void *ptr);
-
-  void setupNetwork(char *cfgfile, char *weightfile, char *datafile, float thresh,
-                    char **names, int classes,
-                    int delay, char *prefix, int avg_frames, float hier, int w, int h,
-                    int frames, int fullscreen);
-
-  void yolo();
-
-  IplImageWithHeader_ getIplImageWithHeader();
-
-  bool getImageStatus(void);
-
-  bool isNodeRunning(void);
-
-  void *publishInThread();
-};
-
-} /* namespace darknet_ros*/
diff --git a/darknet_ros/include/darknet_ros/image_interface.h b/darknet_ros/include/darknet_ros/image_interface.h
deleted file mode 100644
index 2aa1353..0000000
--- a/darknet_ros/include/darknet_ros/image_interface.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * image_interface.h
- *
- *  Created on: Dec 19, 2016
- *      Author: Marko Bjelonic
- *   Institute: ETH Zurich, Robotic Systems Lab
- */
-
-#ifndef IMAGE_INTERFACE_H
-#define IMAGE_INTERFACE_H
-
-#include "opencv2/highgui/highgui_c.h"
-#include "opencv2/imgproc/imgproc_c.h"
-#include "opencv2/core/version.hpp"
-
-#include "image.h"
-
-static float get_pixel(image m, int x, int y, int c);
-image **load_alphabet_with_file(char *datafile);
-void generate_image(image p, IplImage *disp);
-
-#endif
diff --git a/darknet_ros/launch/darknet_ros.launch.py b/darknet_ros/launch/darknet_ros.launch.py
deleted file mode 100644
index 0cd39ec..0000000
--- a/darknet_ros/launch/darknet_ros.launch.py
+++ /dev/null
@@ -1,63 +0,0 @@
-import os
-
-from ament_index_python.packages import get_package_share_directory
-
-from launch import LaunchDescription
-from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, SetEnvironmentVariable
-from launch.launch_description_sources import PythonLaunchDescriptionSource
-from launch.substitutions import LaunchConfiguration
-from launch_ros.actions import Node
-
-def generate_launch_description():
-  darknet_ros_share_dir = get_package_share_directory('darknet_ros')
-
-  image = LaunchConfiguration('image', default = '/camera/rgb/image_raw')
-  yolo_weights_path = LaunchConfiguration('yolo_weights_path', default = darknet_ros_share_dir + '/yolo_network_config/weights')
-  yolo_config_path = LaunchConfiguration('yolo_config_path', default = darknet_ros_share_dir + '/yolo_network_config/cfg')
-  ros_param_file = LaunchConfiguration('ros_param_file', default = darknet_ros_share_dir + 'config/ros.yaml')
-  network_param_file = LaunchConfiguration('network_param_file', default = darknet_ros_share_dir + 'config/yolov2-tiny.yaml')
-
-  declare_image_cmd = DeclareLaunchArgument(
-    'image',
-    default_value = '/camera/rgb/image_raw',
-    description = 'Image topic')
-  declare_yolo_weights_path_cmd = DeclareLaunchArgument(
-    'yolo_weights_path',
-    default_value = darknet_ros_share_dir + '/yolo_network_config/weights',
-    description = 'Path to yolo weights') 
-  declare_yolo_config_path_cmd = DeclareLaunchArgument(
-    'yolo_config_path',
-    default_value = darknet_ros_share_dir + '/yolo_network_config/cfg',
-    description = 'Path to yolo config') 
-  declare_ros_param_file_cmd = DeclareLaunchArgument(
-    'ros_param_file',
-    default_value = darknet_ros_share_dir + '/config/ros.yaml',
-    description = 'Path to file with ROS related config')  
-  declare_network_param_file_cmd = DeclareLaunchArgument(
-    'network_param_file',
-    default_value = darknet_ros_share_dir + '/config/yolov2-tiny.yaml',
-    description = 'Path to file with network param file')  
-
-  darknet_ros_cmd = Node(
-    package='darknet_ros',
-    node_executable='darknet_ros',
-    node_name='darknet_ros',
-    output='screen',
-    parameters=[ros_param_file, network_param_file,
-      {
-        "config_path": yolo_config_path, 
-        "weights_path": yolo_weights_path,
-      },
-    ])
-
-  ld = LaunchDescription()
-
-  ld.add_action(declare_image_cmd)
-  ld.add_action(declare_yolo_weights_path_cmd)
-  ld.add_action(declare_yolo_config_path_cmd)
-  ld.add_action(declare_ros_param_file_cmd)
-  ld.add_action(declare_network_param_file_cmd)
-  
-  ld.add_action(darknet_ros_cmd)
-
-  return ld
diff --git a/darknet_ros/src/YoloObjectDetector.cpp b/darknet_ros/src/YoloObjectDetector.cpp
deleted file mode 100644
index 67d5c3b..0000000
--- a/darknet_ros/src/YoloObjectDetector.cpp
+++ /dev/null
@@ -1,821 +0,0 @@
-/*
- * YoloObjectDetector.cpp
- *
- *  Created on: Dec 19, 2016
- *      Author: Marko Bjelonic
- *   Institute: ETH Zurich, Robotic Systems Lab
- */
-
-// yolo object detector
-#include "darknet_ros/YoloObjectDetector.hpp"
-
-// Check for xServer
-#include <X11/Xlib.h>
-
-#ifdef DARKNET_FILE_PATH
-std::string darknetFilePath_ = DARKNET_FILE_PATH;
-#else
-#error Path of darknet repository is not defined in CMakeLists.txt.
-#endif
-
-namespace darknet_ros {
-
-char *cfg;
-char *weights;
-char *data;
-char **detectionNames;
-
-YoloObjectDetector::YoloObjectDetector()
-    : Node("darknet_ros"),
-      numClasses_(0),
-      classLabels_(0),
-      rosBoxes_(0),
-      rosBoxCounter_(0),
-      action_active_(false),
-      preempt_requested_(false)
-{
-  RCLCPP_INFO(get_logger(), "[YoloObjectDetector] Node started.");
-
-  declare_parameter("image_view.enable_opencv", true);
-  declare_parameter("image_view.wait_key_delay", 3);
-  declare_parameter("image_view.enable_console_output", false);
-  declare_parameter("yolo_model.detection_classes.names", std::vector<std::string>(0));
-
-  declare_parameter("yolo_model.threshold.value", 0.3f);
-  declare_parameter("yolo_model.weight_file.name", std::string("yolov2-tiny.weights"));
-  declare_parameter("weights_path", std::string("/default"));
-
-  declare_parameter("yolo_model.config_file.name", std::string("yolov2-tiny.cfg"));
-  declare_parameter("config_path", std::string("/default"));
-
-  declare_parameter("subscribers.camera_reading.topic", std::string("/camera/image_raw"));
-  declare_parameter("subscribers.camera_reading.queue_size", 1);
-  declare_parameter("publishers.object_detector.topic", std::string("found_object"));
-  declare_parameter("publishers.object_detector.queue_size", 1);
-  declare_parameter("publishers.object_detector.latch", false);
-  declare_parameter("publishers.bounding_boxes.topic", std::string("bounding_boxes"));
-  declare_parameter("publishers.bounding_boxes.queue_size", 1);
-  declare_parameter("publishers.bounding_boxes.latch", false);
-  declare_parameter("publishers.detection_image.topic", std::string("detection_image"));
-  declare_parameter("publishers.detection_image.queue_size", 1);
-  declare_parameter("publishers.detection_image.latch", true);
-
-  declare_parameter("actions.camera_reading.topic", std::string("check_for_objects"));
-}
-
-YoloObjectDetector::~YoloObjectDetector()
-{
-  {
-    std::unique_lock<std::shared_mutex> lockNodeStatus(mutexNodeStatus_);
-    isNodeRunning_ = false;
-  }
-  yoloThread_.join();
-}
-
-bool YoloObjectDetector::readParameters()
-{
-  // Load common parameters.
-  get_parameter("image_view.enable_opencv", viewImage_);
-  get_parameter("image_view.wait_key_delay", waitKeyDelay_);
-  get_parameter("image_view.enable_console_output", enableConsoleOutput_);
-
-  // Check if Xserver is running on Linux.
-  if (XOpenDisplay(NULL)) {
-    // Do nothing!
-    RCLCPP_INFO(get_logger(), "[YoloObjectDetector] Xserver is running.");
-  } else {
-    RCLCPP_INFO(get_logger(), "[YoloObjectDetector] Xserver is not running.");
-    viewImage_ = false;
-  }
-
-  // Set vector sizes.
-  get_parameter("yolo_model.detection_classes.names", classLabels_);
-  numClasses_ = classLabels_.size();
-  rosBoxes_ = std::vector<std::vector<RosBox_> >(numClasses_);
-  rosBoxCounter_ = std::vector<int>(numClasses_);
-
-  return true;
-}
-
-void YoloObjectDetector::init()
-{
-  // Read parameters from config file.
-  if (!readParameters()) {
-    rclcpp::shutdown();
-  }
-
-
-  RCLCPP_INFO(get_logger(), "[YoloObjectDetector] init().");
-
-  // Initialize deep network of darknet.
-  std::string weightsPath;
-  std::string configPath;
-  std::string dataPath;
-  std::string configModel;
-  std::string weightsModel;
-
-  // Threshold of object detection.
-  float thresh;
-  get_parameter("yolo_model.threshold.value", thresh);
-
-  // Path to weights file.
-  get_parameter("yolo_model.weight_file.name", weightsModel);
-  get_parameter("weights_path", weightsPath);
-  weightsPath += "/" + weightsModel;
-  weights = new char[weightsPath.length() + 1];
-  strcpy(weights, weightsPath.c_str());
-
-  // Path to config file.
-  get_parameter("yolo_model.config_file.name", configModel);
-  get_parameter("config_path", configPath);
-  configPath += "/" + configModel;
-  cfg = new char[configPath.length() + 1];
-  strcpy(cfg, configPath.c_str());
-
-  // Path to data folder.
-  dataPath = darknetFilePath_;
-  dataPath += "/data";
-  data = new char[dataPath.length() + 1];
-  strcpy(data, dataPath.c_str());
-
-  // Get classes.
-  detectionNames = (char**) realloc((void*) detectionNames, (numClasses_ + 1) * sizeof(char*));
-  for (int i = 0; i < numClasses_; i++) {
-    detectionNames[i] = new char[classLabels_[i].length() + 1];
-    strcpy(detectionNames[i], classLabels_[i].c_str());
-  }
-
-  // Load network.
-  setupNetwork(cfg, weights, data, thresh, detectionNames, numClasses_,
-                0, 0, 1, 0.5, 0, 0, 0, 0);
-  yoloThread_ = std::thread(&YoloObjectDetector::yolo, this);
-
-  // Initialize publisher and subscriber.
-  std::string cameraTopicName;
-  int cameraQueueSize;
-  std::string objectDetectorTopicName;
-  int objectDetectorQueueSize;
-  bool objectDetectorLatch;
-  std::string boundingBoxesTopicName;
-  int boundingBoxesQueueSize;
-  bool boundingBoxesLatch;
-  std::string detectionImageTopicName;
-  int detectionImageQueueSize;
-  bool detectionImageLatch;
-
-  get_parameter("subscribers.camera_reading.topic", cameraTopicName);
-  get_parameter("subscribers.camera_reading.queue_size", cameraQueueSize);
-  get_parameter("publishers.object_detector.topic", objectDetectorTopicName);
-  get_parameter("publishers.object_detector.queue_size", objectDetectorQueueSize);
-  get_parameter("publishers.object_detector.latch", objectDetectorLatch);
-  get_parameter("publishers.bounding_boxes.topic", boundingBoxesTopicName);
-  get_parameter("publishers.bounding_boxes.queue_size", boundingBoxesQueueSize);
-  get_parameter("publishers.bounding_boxes.latch", boundingBoxesLatch);
-  get_parameter("publishers.detection_image.topic", detectionImageTopicName);
-  get_parameter("publishers.detection_image.queue_size", detectionImageQueueSize);
-  get_parameter("publishers.detection_image.latch", detectionImageLatch);
-
-  it_ = std::make_shared<image_transport::ImageTransport>(shared_from_this());
-  
-  using std::placeholders::_1;
-  imageSubscriber_ = it_->subscribe(cameraTopicName, cameraQueueSize,
-    std::bind(&YoloObjectDetector::cameraCallback, this, _1));
-
-  rclcpp::QoS object_publisher_qos(objectDetectorQueueSize);
-  if (objectDetectorLatch) {
-    object_publisher_qos.transient_local();
-  }
-  objectPublisher_ = this->create_publisher<darknet_ros_msgs::msg::ObjectCount>(
-    objectDetectorTopicName, object_publisher_qos);
-    
-  rclcpp::QoS bounding_boxes_publisher_qos(boundingBoxesQueueSize);
-  if (boundingBoxesLatch) {
-    bounding_boxes_publisher_qos.transient_local();
-  }
-  boundingBoxesPublisher_ = this->create_publisher<darknet_ros_msgs::msg::BoundingBoxes>(
-      boundingBoxesTopicName, bounding_boxes_publisher_qos);
-
-  rclcpp::QoS detection_image_publisher_qos(detectionImageQueueSize);
-  if (detectionImageLatch) {
-    detection_image_publisher_qos.transient_local();
-  }
-  detectionImagePublisher_ = this->create_publisher<sensor_msgs::msg::Image>(
-    detectionImageTopicName, detection_image_publisher_qos);
-
-  // Action servers.
-  std::string checkForObjectsActionName;
-  get_parameter("actions.camera_reading.topic", checkForObjectsActionName);
-
-  using std::placeholders::_2;
-  this->checkForObjectsActionServer_ = rclcpp_action::create_server<CheckForObjectsAction>(
-    this->get_node_base_interface(),
-    this->get_node_clock_interface(),
-    this->get_node_logging_interface(),
-    this->get_node_waitables_interface(),
-    "checkForObjectsActionName",
-    std::bind(&YoloObjectDetector::checkForObjectsActionGoalCB, this, _1, _2),
-    std::bind(&YoloObjectDetector::checkForObjectsActionPreemptCB, this, _1),
-    std::bind(&YoloObjectDetector::checkForObjectsActionAcceptedCB, this, _1));
-}
-
-void YoloObjectDetector::cameraCallback(const sensor_msgs::msg::Image::ConstSharedPtr & msg)
-{
-  RCLCPP_DEBUG(get_logger(), "[YoloObjectDetector] USB image received.");
-
-  cv_bridge::CvImagePtr cam_image;
-
-  try {
-    cam_image = cv_bridge::toCvCopy(msg, "bgr8");
-  } catch (cv_bridge::Exception& e) {
-    RCLCPP_ERROR(get_logger(), "cv_bridge exception: %s", e.what());
-    return;
-  }
-
-  if (cam_image) {
-    {
-      std::unique_lock<std::shared_mutex> lockImageCallback(mutexImageCallback_);
-      imageHeader_ = msg->header;
-      camImageCopy_ = cam_image->image.clone();
-    }
-    {
-      std::unique_lock<std::shared_mutex> lockImageStatus(mutexImageStatus_);
-      imageStatus_ = true;
-    }
-    frameWidth_ = cam_image->image.size().width;
-    frameHeight_ = cam_image->image.size().height;
-  }
-  return;
-}
-
-rclcpp_action::GoalResponse YoloObjectDetector::checkForObjectsActionGoalCB(
-  const rclcpp_action::GoalUUID & uuid,
-  std::shared_ptr<const CheckForObjectsAction::Goal> goal)
-{
-  RCLCPP_DEBUG(get_logger(), "[YoloObjectDetector] Start check for objects action.");
-
-  auto imageAction = goal->image;
-
-  cv_bridge::CvImagePtr cam_image;
-
-  try {
-    cam_image = cv_bridge::toCvCopy(imageAction, "bgr8");
-  } catch (cv_bridge::Exception& e) {
-    RCLCPP_ERROR(get_logger(), "cv_bridge exception: %s", e.what());
-    rclcpp_action::GoalResponse::REJECT;
-  }
-
-  if (cam_image) {
-    {
-      std::unique_lock<std::shared_mutex> lockImageCallback(mutexImageCallback_);
-      camImageCopy_ = cam_image->image.clone();
-    }
-    {
-      std::unique_lock<std::shared_mutex> lockImageCallback(mutexActionStatus_);
-      actionId_ = goal->id;
-    }
-    {
-      std::unique_lock<std::shared_mutex> lockImageStatus(mutexImageStatus_);
-      imageStatus_ = true;
-    }
-    frameWidth_ = cam_image->image.size().width;
-    frameHeight_ = cam_image->image.size().height;
-  }
-  preempt_requested_ = false;
-  return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
-}
-
-rclcpp_action::CancelResponse
-YoloObjectDetector::checkForObjectsActionPreemptCB(
-  const std::shared_ptr<GoalHandleCheckForObjectsAction> goal_handle)
-{
-  RCLCPP_DEBUG(get_logger(), "[YoloObjectDetector] Preempt check for objects action.");
-  preempt_requested_ = true;
-  return rclcpp_action::CancelResponse::ACCEPT;
-}
-
-void
-YoloObjectDetector::checkForObjectsActionAcceptedCB(
-  const std::shared_ptr<GoalHandleCheckForObjectsAction> goal_handle)
-{
-  RCLCPP_DEBUG(get_logger(), "[YoloObjectDetector] action accepted.");
-  action_active_ = true;
-  goal_handle_ = goal_handle;
-}
-
-bool YoloObjectDetector::isCheckingForObjects() const
-{
-  return (rclcpp::ok() && action_active_ && !preempt_requested_);
-}
-
-bool YoloObjectDetector::publishDetectionImage(const cv::Mat& detectionImage)
-{
-  if (detectionImagePublisher_->get_subscription_count() < 1)
-    return false;
-  cv_bridge::CvImage cvImage;
-  cvImage.header.stamp = this->now();
-  cvImage.header.frame_id = "detection_image";
-  cvImage.encoding = "bgr8";
-  cvImage.image = detectionImage;
-  detectionImagePublisher_->publish(*cvImage.toImageMsg());
-  RCLCPP_DEBUG(get_logger(), "Detection image has been published.");
-  return true;
-}
-
-// double YoloObjectDetector::getWallTime()
-// {
-//   struct timeval time;
-//   if (gettimeofday(&time, NULL)) {
-//     return 0;
-//   }
-//   return (double) time.tv_sec + (double) time.tv_usec * .000001;
-// }
-
-int YoloObjectDetector::sizeNetwork(network *net)
-{
-  int i;
-  int count = 0;
-  for(i = 0; i < net->n; ++i){
-    layer l = net->layers[i];
-    if(l.type == YOLO || l.type == REGION || l.type == DETECTION){
-      count += l.outputs;
-    }
-  }
-  return count;
-}
-
-void YoloObjectDetector::rememberNetwork(network *net)
-{
-  int i;
-  int count = 0;
-  for(i = 0; i < net->n; ++i){
-    layer l = net->layers[i];
-    if(l.type == YOLO || l.type == REGION || l.type == DETECTION){
-      memcpy(predictions_[demoIndex_] + count, net->layers[i].output, sizeof(float) * l.outputs);
-      count += l.outputs;
-    }
-  }
-}
-
-detection *YoloObjectDetector::avgPredictions(network *net, int *nboxes)
-{
-  int i, j;
-  int count = 0;
-  fill_cpu(demoTotal_, 0, avg_, 1);
-  for(j = 0; j < demoFrame_; ++j){
-    axpy_cpu(demoTotal_, 1./demoFrame_, predictions_[j], 1, avg_, 1);
-  }
-  for(i = 0; i < net->n; ++i){
-    layer l = net->layers[i];
-    if(l.type == YOLO || l.type == REGION || l.type == DETECTION){
-      memcpy(l.output, avg_ + count, sizeof(float) * l.outputs);
-      count += l.outputs;
-    }
-  }
-  detection *dets = get_network_boxes(net, buff_[0].w, buff_[0].h, demoThresh_, demoHier_, 0, 1, nboxes);
-  return dets;
-}
-
-void *YoloObjectDetector::detectInThread()
-{
-  running_ = 1;
-  float nms = .4;
-
-  layer l = net_->layers[net_->n - 1];
-  float *X = buffLetter_[(buffIndex_ + 2) % 3].data;
-  float *prediction = network_predict(net_, X);
-
-  rememberNetwork(net_);
-  detection *dets = 0;
-  int nboxes = 0;
-  dets = avgPredictions(net_, &nboxes);
-
-  if (nms > 0) do_nms_obj(dets, nboxes, l.classes, nms);
-
-  if (enableConsoleOutput_) {
-    printf("\033[2J");
-    printf("\033[1;1H");
-    printf("\nFPS:%.1f\n",fps_);
-    printf("Objects:\n\n");
-  }
-  image display = buff_[(buffIndex_+2) % 3];
-  draw_detections(display, dets, nboxes, demoThresh_, demoNames_, demoAlphabet_, demoClasses_);
-
-  // extract the bounding boxes and send them to ROS
-  int i, j;
-  int count = 0;
-  for (i = 0; i < nboxes; ++i) {
-    float xmin = dets[i].bbox.x - dets[i].bbox.w / 2.;
-    float xmax = dets[i].bbox.x + dets[i].bbox.w / 2.;
-    float ymin = dets[i].bbox.y - dets[i].bbox.h / 2.;
-    float ymax = dets[i].bbox.y + dets[i].bbox.h / 2.;
-
-    if (xmin < 0)
-      xmin = 0;
-    if (ymin < 0)
-      ymin = 0;
-    if (xmax > 1)
-      xmax = 1;
-    if (ymax > 1)
-      ymax = 1;
-
-    // iterate through possible boxes and collect the bounding boxes
-    for (j = 0; j < demoClasses_; ++j) {
-      if (dets[i].prob[j]) {
-        float x_center = (xmin + xmax) / 2;
-        float y_center = (ymin + ymax) / 2;
-        float BoundingBox_width = xmax - xmin;
-        float BoundingBox_height = ymax - ymin;
-
-        // define bounding box
-        // BoundingBox must be 1% size of frame (3.2x2.4 pixels)
-        if (BoundingBox_width > 0.01 && BoundingBox_height > 0.01) {
-          roiBoxes_[count].x = x_center;
-          roiBoxes_[count].y = y_center;
-          roiBoxes_[count].w = BoundingBox_width;
-          roiBoxes_[count].h = BoundingBox_height;
-          roiBoxes_[count].Class = j;
-          roiBoxes_[count].prob = dets[i].prob[j];
-          count++;
-        }
-      }
-    }
-  }
-
-  // create array to store found bounding boxes
-  // if no object detected, make sure that ROS knows that num = 0
-  if (count == 0) {
-    roiBoxes_[0].num = 0;
-  } else {
-    roiBoxes_[0].num = count;
-  }
-
-  free_detections(dets, nboxes);
-  demoIndex_ = (demoIndex_ + 1) % demoFrame_;
-  running_ = 0;
-  return 0;
-}
-
-
-void ipl_into_image_cp(IplImage* src, image im)
-{
-    unsigned char *data = (unsigned char *)src->imageData;
-    int h = src->height;
-    int w = src->width;
-    int c = src->nChannels;
-    int step = src->widthStep;
-    int i, j, k;
-
-    for(i = 0; i < h; ++i){
-        for(k= 0; k < c; ++k){
-            for(j = 0; j < w; ++j){
-                im.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.;
-            }
-        }
-    }
-}
-
-void *YoloObjectDetector::fetchInThread()
-{
-  {
-    std::shared_lock<std::shared_mutex> lock(mutexImageCallback_);
-    IplImageWithHeader_ imageAndHeader = getIplImageWithHeader();
-    IplImage* ROS_img = imageAndHeader.image;
-    ipl_into_image_cp(ROS_img, buff_[buffIndex_]);
-    headerBuff_[buffIndex_] = imageAndHeader.header;
-    buffId_[buffIndex_] = actionId_;
-  }
-  rgbgr_image(buff_[buffIndex_]);
-  letterbox_image_into(buff_[buffIndex_], net_->w, net_->h, buffLetter_[buffIndex_]);
-  return 0;
-}
-
-
-float get_pixel_cp(image m, int x, int y, int c)
-{
-    assert(x < m.w && y < m.h && c < m.c);
-    return m.data[c*m.h*m.w + y*m.w + x];
-}
-
-int windows = 0;
-
-void show_image_cv_cp(image p, const char *name, IplImage *disp)
-{
-    int x,y,k;
-    if(p.c == 3) rgbgr_image(p);
-    //normalize_image(copy);
-
-    char buff[256];
-    //sprintf(buff, "%s (%d)", name, windows);
-    sprintf(buff, "%s", name);
-
-    int step = disp->widthStep;
-    cvNamedWindow(buff, CV_WINDOW_NORMAL); 
-    //cvMoveWindow(buff, 100*(windows%10) + 200*(windows/10), 100*(windows%10));
-    ++windows;
-    for(y = 0; y < p.h; ++y){
-        for(x = 0; x < p.w; ++x){
-            for(k= 0; k < p.c; ++k){
-                disp->imageData[y*step + x*p.c + k] = (unsigned char)(get_pixel_cp(p,x,y,k)*255);
-            }
-        }
-    }
-    if(0){
-        int w = 448;
-        int h = w*p.h/p.w;
-        if(h > 1000){
-            h = 1000;
-            w = h*p.w/p.h;
-        }
-        IplImage *buffer = disp;
-        disp = cvCreateImage(cvSize(w, h), buffer->depth, buffer->nChannels);
-        cvResize(buffer, disp, CV_INTER_LINEAR);
-        cvReleaseImage(&buffer);
-    }
-    cvShowImage(buff, disp);
-}
-
-void *YoloObjectDetector::displayInThread(void *ptr)
-{
-  show_image_cv_cp(buff_[(buffIndex_ + 1)%3], "YOLO V3", ipl_);
-  int c = cv::waitKey(waitKeyDelay_);
-  if (c != -1) c = c%256;
-  if (c == 27) {
-      demoDone_ = 1;
-      return 0;
-  } else if (c == 82) {
-      demoThresh_ += .02;
-  } else if (c == 84) {
-      demoThresh_ -= .02;
-      if(demoThresh_ <= .02) demoThresh_ = .02;
-  } else if (c == 83) {
-      demoHier_ += .02;
-  } else if (c == 81) {
-      demoHier_ -= .02;
-      if(demoHier_ <= .0) demoHier_ = .0;
-  }
-  return 0;
-}
-
-void *YoloObjectDetector::displayLoop(void *ptr)
-{
-  while (1) {
-    displayInThread(0);
-  }
-}
-
-void *YoloObjectDetector::detectLoop(void *ptr)
-{
-  while (1) {
-    detectInThread();
-  }
-}
-
-
-image **load_alphabet_with_file_cp(char *datafile) {
-  int i, j;
-  const int nsize = 8;
-  image **alphabets = (image**)calloc(nsize, sizeof(image));
-  char* labels = "/labels/%d_%d.png";
-  char * files = (char *) malloc(1 + strlen(datafile)+ strlen(labels) );
-  strcpy(files, datafile);
-  strcat(files, labels);
-  for(j = 0; j < nsize; ++j){
-    alphabets[j] = (image*)calloc(128, sizeof(image));
-    for(i = 32; i < 127; ++i){
-      char buff[256];
-      sprintf(buff, files, i, j);
-      alphabets[j][i] = load_image_color(buff, 0, 0);
-    }
-  }
-  return alphabets;
-}
-
-void YoloObjectDetector::setupNetwork(char *cfgfile, char *weightfile, char *datafile, float thresh,
-                                      char **names, int classes,
-                                      int delay, char *prefix, int avg_frames, float hier, int w, int h,
-                                      int frames, int fullscreen)
-{
-  demoPrefix_ = prefix;
-  demoDelay_ = delay;
-  demoFrame_ = avg_frames;
-  image **alphabet = load_alphabet_with_file_cp(datafile);
-  demoNames_ = names;
-  demoAlphabet_ = alphabet;
-  demoClasses_ = classes;
-  demoThresh_ = thresh;
-  demoHier_ = hier;
-  fullScreen_ = fullscreen;
-  printf("YOLO V3\n");
-  net_ = load_network(cfgfile, weightfile, 0);
-  set_batch_network(net_, 1);
-}
-
-void generate_image_cp(image p, IplImage *disp)
-{
-    int x,y,k;
-    if(p.c == 3) rgbgr_image(p);
-    //normalize_image(copy);
-
-    int step = disp->widthStep;
-    for(y = 0; y < p.h; ++y){
-        for(x = 0; x < p.w; ++x){
-            for(k= 0; k < p.c; ++k){
-                disp->imageData[y*step + x*p.c + k] = (unsigned char)(get_pixel_cp(p,x,y,k)*255);
-            }
-        }
-    }
-}
-
-image ipl_to_image_cp(IplImage* src)
-{
-    int h = src->height;
-    int w = src->width;
-    int c = src->nChannels;
-    image out = make_image(w, h, c);
-    ipl_into_image_cp(src, out);
-    return out;
-}
-
-void YoloObjectDetector::yolo()
-{
-  const auto wait_duration = std::chrono::milliseconds(2000);
-  while (!getImageStatus()) {
-    printf("Waiting for image.\n");
-    if (!isNodeRunning()) {
-      return;
-    }
-    std::this_thread::sleep_for(wait_duration);
-  }
-
-  std::thread detect_thread;
-  std::thread fetch_thread;
-
-  srand(2222222);
-
-  int i;
-  demoTotal_ = sizeNetwork(net_);
-  predictions_ = (float **) calloc(demoFrame_, sizeof(float*));
-  for (i = 0; i < demoFrame_; ++i){
-      predictions_[i] = (float *) calloc(demoTotal_, sizeof(float));
-  }
-  avg_ = (float *) calloc(demoTotal_, sizeof(float));
-
-  layer l = net_->layers[net_->n - 1];
-  roiBoxes_ = (darknet_ros::RosBox_ *) calloc(l.w * l.h * l.n, sizeof(darknet_ros::RosBox_));
-
-  {
-    std::shared_lock<std::shared_mutex> lock(mutexImageCallback_);
-    IplImageWithHeader_ imageAndHeader = getIplImageWithHeader();
-    IplImage* ROS_img = imageAndHeader.image;
-    buff_[0] = ipl_to_image_cp(ROS_img);
-    headerBuff_[0] = imageAndHeader.header;
-  }
-  buff_[1] = copy_image(buff_[0]);
-  buff_[2] = copy_image(buff_[0]);
-  headerBuff_[1] = headerBuff_[0];
-  headerBuff_[2] = headerBuff_[0];
-  buffLetter_[0] = letterbox_image(buff_[0], net_->w, net_->h);
-  buffLetter_[1] = letterbox_image(buff_[0], net_->w, net_->h);
-  buffLetter_[2] = letterbox_image(buff_[0], net_->w, net_->h);
-  ipl_ = cvCreateImage(cvSize(buff_[0].w, buff_[0].h), IPL_DEPTH_8U, buff_[0].c);
-
-  int count = 0;
-
-  if (!demoPrefix_ && viewImage_) {
-      cv::namedWindow("YOLO V3", cv::WINDOW_NORMAL);
-    if (fullScreen_) {
-      cv::setWindowProperty("YOLO V3", cv::WND_PROP_FULLSCREEN, cv::WINDOW_FULLSCREEN);
-    } else {
-      cv::moveWindow("YOLO V3", 0, 0);
-      cv::resizeWindow("YOLO V3", 640, 480);
-    }
-  }
-
-  demoTime_ = what_time_is_it_now();
-
-  while (!demoDone_) {
-    buffIndex_ = (buffIndex_ + 1) % 3;
-    fetch_thread = std::thread(&YoloObjectDetector::fetchInThread, this);
-    detect_thread = std::thread(&YoloObjectDetector::detectInThread, this);
-    if (!demoPrefix_) {
-      fps_ = 1./(what_time_is_it_now() - demoTime_);
-      demoTime_ = what_time_is_it_now();
-      if (viewImage_) {
-        displayInThread(0);
-      } else {
-        generate_image_cp(buff_[(buffIndex_ + 1)%3], ipl_);
-      }
-      publishInThread();
-    } else {
-      char name[256];
-      sprintf(name, "%s_%08d", demoPrefix_, count);
-      save_image(buff_[(buffIndex_ + 1) % 3], name);
-    }
-    fetch_thread.join();
-    detect_thread.join();
-    ++count;
-    if (!isNodeRunning()) {
-      demoDone_ = true;
-    }
-  }
-
-}
-
-IplImageWithHeader_ YoloObjectDetector::getIplImageWithHeader()
-{
-  IplImage* ROS_img = new IplImage();
-  *ROS_img = cvIplImage(camImageCopy_);
-  IplImageWithHeader_ header = {.image = ROS_img, .header = imageHeader_};
-  return header;
-}
-
-bool YoloObjectDetector::getImageStatus(void)
-{
-  std::shared_lock<std::shared_mutex> lock(mutexImageStatus_);
-  return imageStatus_;
-}
-
-bool YoloObjectDetector::isNodeRunning(void)
-{
-  std::shared_lock<std::shared_mutex> lock(mutexNodeStatus_);
-  return isNodeRunning_;
-}
-
-void *YoloObjectDetector::publishInThread()
-{
-  // Publish image.
-  cv::Mat cvImage = cv::cvarrToMat(ipl_);
-  if (!publishDetectionImage(cv::Mat(cvImage))) {
-    RCLCPP_DEBUG(get_logger(), "Detection image has not been broadcasted.");
-  }
-
-  // Publish bounding boxes and detection result.
-  int num = roiBoxes_[0].num;
-  if (num > 0 && num <= 100) {
-    for (int i = 0; i < num; i++) {
-      for (int j = 0; j < numClasses_; j++) {
-        if (roiBoxes_[i].Class == j) {
-          rosBoxes_[j].push_back(roiBoxes_[i]);
-          rosBoxCounter_[j]++;
-        }
-      }
-    }
-
-    darknet_ros_msgs::msg::ObjectCount msg;
-    msg.header.stamp = this->now();
-    msg.header.frame_id = "detection";
-    msg.count = num;
-    objectPublisher_->publish(msg);
-
-    for (int i = 0; i < numClasses_; i++) {
-      if (rosBoxCounter_[i] > 0) {
-        darknet_ros_msgs::msg::BoundingBox boundingBox;
-
-        for (int j = 0; j < rosBoxCounter_[i]; j++) {
-          int xmin = (rosBoxes_[i][j].x - rosBoxes_[i][j].w / 2) * frameWidth_;
-          int ymin = (rosBoxes_[i][j].y - rosBoxes_[i][j].h / 2) * frameHeight_;
-          int xmax = (rosBoxes_[i][j].x + rosBoxes_[i][j].w / 2) * frameWidth_;
-          int ymax = (rosBoxes_[i][j].y + rosBoxes_[i][j].h / 2) * frameHeight_;
-
-          boundingBox.class_id = classLabels_[i];
-          boundingBox.id = i;
-          boundingBox.probability = rosBoxes_[i][j].prob;
-          boundingBox.xmin = xmin;
-          boundingBox.ymin = ymin;
-          boundingBox.xmax = xmax;
-          boundingBox.ymax = ymax;
-          boundingBoxesResults_.bounding_boxes.push_back(boundingBox);
-        }
-      }
-    }
-    boundingBoxesResults_.header.stamp = this->now();
-    boundingBoxesResults_.header.frame_id = "detection";
-    boundingBoxesResults_.image_header = headerBuff_[(buffIndex_ + 1) % 3];
-    boundingBoxesPublisher_->publish(boundingBoxesResults_);
-  } else {
-    darknet_ros_msgs::msg::ObjectCount msg;
-    msg.header.stamp = this->now();
-    msg.header.frame_id = "detection";
-    msg.count = 0;
-    objectPublisher_->publish(msg);
-  }
-  if (isCheckingForObjects()) {
-    RCLCPP_DEBUG(get_logger(), "[YoloObjectDetector] check for objects in image.");
-    auto result = std::make_shared<CheckForObjectsAction::Result>();
-
-    result->id = buffId_[0];
-    result->bounding_boxes = boundingBoxesResults_;
-    goal_handle_->succeed(result);
-    action_active_ = false;
-  }
-  boundingBoxesResults_.bounding_boxes.clear();
-  for (int i = 0; i < numClasses_; i++) {
-    rosBoxes_[i].clear();
-    rosBoxCounter_[i] = 0;
-  }
-
-  return 0;
-}
-
-
-} /* namespace darknet_ros*/
diff --git a/darknet_ros/src/image_interface.c b/darknet_ros/src/image_interface.c
deleted file mode 100644
index 8ee77cd..0000000
--- a/darknet_ros/src/image_interface.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * image_interface.c
- *
- *  Created on: Dec 19, 2016
- *      Author: Marko Bjelonic
- *   Institute: ETH Zurich, Robotic Systems Lab
- */
-
-#include "darknet_ros/image_interface.h"
-
-static float get_pixel(image m, int x, int y, int c)
-{
-    assert(x < m.w && y < m.h && c < m.c);
-    return m.data[c*m.h*m.w + y*m.w + x];
-}
-
-image **load_alphabet_with_file(char *datafile) {
-  int i, j;
-  const int nsize = 8;
-  image **alphabets = (image**)calloc(nsize, sizeof(image));
-  char* labels = "/labels/%d_%d.png";
-  char * files = (char *) malloc(1 + strlen(datafile)+ strlen(labels) );
-  strcpy(files, datafile);
-  strcat(files, labels);
-  for(j = 0; j < nsize; ++j){
-    alphabets[j] = (image*)calloc(128, sizeof(image));
-    for(i = 32; i < 127; ++i){
-      char buff[256];
-      sprintf(buff, files, i, j);
-      alphabets[j][i] = load_image_color(buff, 0, 0);
-    }
-  }
-  return alphabets;
-}
-
-#ifdef OPENCV
-void generate_image(image p, IplImage *disp)
-{
-    int x,y,k;
-    if(p.c == 3) rgbgr_image(p);
-    //normalize_image(copy);
-
-    int step = disp->widthStep;
-    for(y = 0; y < p.h; ++y){
-        for(x = 0; x < p.w; ++x){
-            for(k= 0; k < p.c; ++k){
-                disp->imageData[y*step + x*p.c + k] = (unsigned char)(get_pixel(p,x,y,k)*255);
-            }
-        }
-    }
-}
-#endif
diff --git a/darknet_ros/src/yolo_object_detector_node.cpp b/darknet_ros/src/yolo_object_detector_node.cpp
deleted file mode 100644
index b9bc067..0000000
--- a/darknet_ros/src/yolo_object_detector_node.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * yolo_obstacle_detector_node.cpp
- *
- *  Created on: Dec 19, 2016
- *      Author: Marko Bjelonic
- *   Institute: ETH Zurich, Robotic Systems Lab
- */
-
-#include "darknet_ros/YoloObjectDetector.hpp"
-#include "rclcpp/rclcpp.hpp"
-
-int main(int argc, char** argv) {
-  rclcpp::init(argc, argv);
-
-  auto yoloObjectDetector = std::make_shared<darknet_ros::YoloObjectDetector>();
-
-  yoloObjectDetector->init();
-  
-  rclcpp::spin(yoloObjectDetector->get_node_base_interface());
-
-  rclcpp::shutdown();
-
-  return 0;
-}
